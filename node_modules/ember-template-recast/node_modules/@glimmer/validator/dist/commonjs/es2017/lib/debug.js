"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logTrackingStack = exports.markTagAsConsumed = exports.assertTagNotConsumed = exports.setTrackingTransactionEnv = exports.resetTrackingTransaction = exports.deprecateMutationsInTrackingTransaction = exports.runInTrackingTransaction = exports.endTrackingTransaction = exports.beginTrackingTransaction = void 0;

var _env = require("@glimmer/env");

let beginTrackingTransaction;
exports.beginTrackingTransaction = beginTrackingTransaction;
let endTrackingTransaction;
exports.endTrackingTransaction = endTrackingTransaction;
let runInTrackingTransaction;
exports.runInTrackingTransaction = runInTrackingTransaction;
let deprecateMutationsInTrackingTransaction;
exports.deprecateMutationsInTrackingTransaction = deprecateMutationsInTrackingTransaction;
let resetTrackingTransaction;
exports.resetTrackingTransaction = resetTrackingTransaction;
let setTrackingTransactionEnv;
exports.setTrackingTransactionEnv = setTrackingTransactionEnv;
let assertTagNotConsumed;
exports.assertTagNotConsumed = assertTagNotConsumed;
let markTagAsConsumed;
exports.markTagAsConsumed = markTagAsConsumed;
let logTrackingStack;
exports.logTrackingStack = logTrackingStack;

if (_env.DEBUG) {
  let CONSUMED_TAGS = null;
  let TRANSACTION_STACK = []; /////////

  let TRANSACTION_ENV = {
    assert(message) {
      throw new Error(message);
    },

    deprecate(message) {
      console.warn(message);
    },

    debugMessage(obj, keyName) {
      let objName;

      if (typeof obj === 'function') {
        objName = obj.name;
      } else if (typeof obj === 'object' && obj !== null) {
        let className = obj.constructor && obj.constructor.name || '(unknown class)';
        objName = `(an instance of ${className})`;
      } else if (obj === undefined) {
        objName = '(an unknown tag)';
      } else {
        objName = String(obj);
      }

      let dirtyString = keyName ? `\`${keyName}\` on \`${objName}\`` : `\`${objName}\``;
      return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;
    }

  };

  exports.setTrackingTransactionEnv = setTrackingTransactionEnv = env => Object.assign(TRANSACTION_ENV, env);

  exports.beginTrackingTransaction = beginTrackingTransaction = (_debugLabel, deprecate = false) => {
    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();
    let debugLabel = _debugLabel || undefined;
    let parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] || null;
    TRANSACTION_STACK.push({
      parent,
      debugLabel,
      deprecate
    });
  };

  exports.endTrackingTransaction = endTrackingTransaction = () => {
    if (TRANSACTION_STACK.length === 0) {
      throw new Error('attempted to close a tracking transaction, but one was not open');
    }

    TRANSACTION_STACK.pop();

    if (TRANSACTION_STACK.length === 0) {
      CONSUMED_TAGS = null;
    }
  };

  exports.resetTrackingTransaction = resetTrackingTransaction = () => {
    let stack = '';

    if (TRANSACTION_STACK.length > 0) {
      stack = logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);
    }

    TRANSACTION_STACK = [];
    CONSUMED_TAGS = null;
    return stack;
  };
  /**
   * Creates a global autotracking transaction. This will prevent any backflow
   * in any `track` calls within the transaction, even if they are not
   * externally consumed.
   *
   * `runInAutotrackingTransaction` can be called within itself, and it will add
   * onto the existing transaction if one exists.
   *
   * TODO: Only throw an error if the `track` is consumed.
   */


  exports.runInTrackingTransaction = runInTrackingTransaction = (fn, debugLabel) => {
    beginTrackingTransaction(debugLabel);

    try {
      fn();
    } finally {
      endTrackingTransaction();
    }
  };
  /**
   * Switches to deprecating within an autotracking transaction, if one exists.
   * If `runInAutotrackingTransaction` is called within the callback of this
   * method, it switches back to throwing an error, allowing zebra-striping of
   * the types of errors that are thrown.
   *
   * Does not start an autotracking transaction.
   *
   * NOTE: For Ember usage only, in general you should assert that these
   * invariants are true.
   */


  exports.deprecateMutationsInTrackingTransaction = deprecateMutationsInTrackingTransaction = (fn, debugLabel) => {
    beginTrackingTransaction(debugLabel, true);

    try {
      fn();
    } finally {
      endTrackingTransaction();
    }
  };

  let nthIndex = (str, pattern, n, startingPos = -1) => {
    let i = startingPos;

    while (n-- > 0 && i++ < str.length) {
      i = str.indexOf(pattern, i);
      if (i < 0) break;
    }

    return i;
  };

  let makeTrackingErrorMessage = (transaction, obj, keyName) => {
    let message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    message.push(`\`${String(keyName)}\` was first used:`);
    message.push(logTrackingStack(transaction));
    message.push(`Stack trace for the update:`);
    return message.join('\n\n');
  };

  exports.logTrackingStack = logTrackingStack = transaction => {
    let trackingStack = [];
    let current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (current === undefined) return '';

    while (current) {
      if (current.debugLabel) {
        trackingStack.unshift(current.debugLabel);
      }

      current = current.parent;
    } // TODO: Use String.prototype.repeat here once we can drop support for IE11


    return trackingStack.map((label, index) => Array(2 * index + 1).join(' ') + label).join('\n');
  };

  exports.markTagAsConsumed = markTagAsConsumed = _tag => {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    CONSUMED_TAGS.set(_tag, TRANSACTION_STACK[TRANSACTION_STACK.length - 1]); // We need to mark the tag and all of its subtags as consumed, so we need to
    // cast it and access its internals. In the future this shouldn't be necessary,
    // this is only for computed properties.

    let tag = _tag;

    if (tag.subtag) {
      markTagAsConsumed(tag.subtag);
    }

    if (tag.subtags) {
      tag.subtags.forEach(tag => markTagAsConsumed(tag));
    }
  };

  exports.assertTagNotConsumed = assertTagNotConsumed = (tag, obj, keyName, forceHardError = false) => {
    if (CONSUMED_TAGS === null) return;
    let transaction = CONSUMED_TAGS.get(tag);
    if (!transaction) return;
    let currentTransaction = TRANSACTION_STACK[TRANSACTION_STACK.length - 1];

    if (currentTransaction.deprecate && !forceHardError) {
      TRANSACTION_ENV.deprecate(makeTrackingErrorMessage(transaction, obj, keyName));
    } else {
      // This hack makes the assertion message nicer, we can cut off the first
      // few lines of the stack trace and let users know where the actual error
      // occurred.
      try {
        TRANSACTION_ENV.assert(makeTrackingErrorMessage(transaction, obj, keyName));
      } catch (e) {
        if (e.stack) {
          let updateStackBegin = e.stack.indexOf('Stack trace for the update:');

          if (updateStackBegin !== -1) {
            let start = nthIndex(e.stack, '\n', 1, updateStackBegin);
            let end = nthIndex(e.stack, '\n', 4, updateStackBegin);
            e.stack = e.stack.substr(0, start) + e.stack.substr(end);
          }
        }

        throw e;
      }
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUVPLElBQUEsd0JBQUE7O0FBR0EsSUFBQSxzQkFBQTs7QUFDQSxJQUFBLHdCQUFBOztBQUdBLElBQUEsdUNBQUE7O0FBRUEsSUFBQSx3QkFBQTs7QUFDQSxJQUFBLHlCQUFBOztBQVFBLElBQUEsb0JBQUE7O0FBSUEsSUFBQSxpQkFBQTs7QUFFQSxJQUFBLGdCQUFBOzs7QUFRUCxJQUFBLFVBQUEsRUFBVztBQUNULE1BQUksYUFBYSxHQUFqQixJQUFBO0FBRUEsTUFBSSxpQkFBaUIsR0FIWixFQUdULENBSFMsQ0FLVDs7QUFFQSxNQUFJLGVBQWUsR0FBRztBQUNwQixJQUFBLE1BQU0sQ0FBQSxPQUFBLEVBQWdCO0FBQ3BCLFlBQU0sSUFBQSxLQUFBLENBQU4sT0FBTSxDQUFOO0FBRmtCLEtBQUE7O0FBS3BCLElBQUEsU0FBUyxDQUFBLE9BQUEsRUFBZ0I7QUFDdkIsTUFBQSxPQUFPLENBQVAsSUFBQSxDQUFBLE9BQUE7QUFOa0IsS0FBQTs7QUFTcEIsSUFBQSxZQUFZLENBQUEsR0FBQSxFQUFBLE9BQUEsRUFBZ0M7QUFDMUMsVUFBQSxPQUFBOztBQUVBLFVBQUksT0FBQSxHQUFBLEtBQUosVUFBQSxFQUErQjtBQUM3QixRQUFBLE9BQU8sR0FBRyxHQUFHLENBQWIsSUFBQTtBQURGLE9BQUEsTUFFTyxJQUFJLE9BQUEsR0FBQSxLQUFBLFFBQUEsSUFBMkIsR0FBRyxLQUFsQyxJQUFBLEVBQTZDO0FBQ2xELFlBQUksU0FBUyxHQUFJLEdBQUcsQ0FBSCxXQUFBLElBQW1CLEdBQUcsQ0FBSCxXQUFBLENBQXBCLElBQUMsSUFBakIsaUJBQUE7QUFFQSxRQUFBLE9BQU8sR0FBRyxtQkFBbUIsU0FBN0IsR0FBQTtBQUhLLE9BQUEsTUFJQSxJQUFJLEdBQUcsS0FBUCxTQUFBLEVBQXVCO0FBQzVCLFFB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LE9BQUEsQ0FBQSxFQUFVO0FBQ1YsWUFBSSxDQUFDLENBQUwsS0FBQSxFQUFhO0FBQ1gsY0FBSSxnQkFBZ0IsR0FBRyxDQUFDLENBQUQsS0FBQSxDQUFBLE9BQUEsQ0FBdkIsNkJBQXVCLENBQXZCOztBQUVBLGNBQUksZ0JBQWdCLEtBQUssQ0FBekIsQ0FBQSxFQUE2QjtBQUMzQixnQkFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBRixLQUFBLEVBQUEsSUFBQSxFQUFBLENBQUEsRUFBcEIsZ0JBQW9CLENBQXBCO0FBQ0EsZ0JBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUYsS0FBQSxFQUFBLElBQUEsRUFBQSxDQUFBLEVBQWxCLGdCQUFrQixDQUFsQjtBQUNBLFlBQUEsQ0FBQyxDQUFELEtBQUEsR0FBVSxDQUFDLENBQUQsS0FBQSxDQUFBLE1BQUEsQ0FBQSxDQUFBLEVBQUEsS0FBQSxJQUEyQixDQUFDLENBQUQsS0FBQSxDQUFBLE1BQUEsQ0FBckMsR0FBcUMsQ0FBckM7QUFDRDtBQUNGOztBQUVELGNBQUEsQ0FBQTtBQUNEO0FBQ0Y7QUFuQ0gsR0FBQTtBQXFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRhZyB9IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmV4cG9ydCBsZXQgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uOlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlLCBkZXByZWNhdGU/OiBib29sZWFuKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbjogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuZXhwb3J0IGxldCBydW5JblRyYWNraW5nVHJhbnNhY3Rpb246XG4gIHwgdW5kZWZpbmVkXG4gIHwgKChmbjogKCkgPT4gdm9pZCwgZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgZGVwcmVjYXRlTXV0YXRpb25zSW5UcmFja2luZ1RyYW5zYWN0aW9uOiB1bmRlZmluZWQgfCAoKGZuOiAoKSA9PiB2b2lkKSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCByZXNldFRyYWNraW5nVHJhbnNhY3Rpb246IHVuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpO1xuZXhwb3J0IGxldCBzZXRUcmFja2luZ1RyYW5zYWN0aW9uRW52OlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZW52OiB7XG4gICAgICBhc3NlcnQ/KG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQ7XG4gICAgICBkZXByZWNhdGU/KG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQ7XG4gICAgICBkZWJ1Z01lc3NhZ2U/KG9iaj86IHVua25vd24sIGtleU5hbWU/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgfSkgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgYXNzZXJ0VGFnTm90Q29uc3VtZWQ6XG4gIHwgdW5kZWZpbmVkXG4gIHwgKDxUPih0YWc6IFRhZywgb2JqPzogVCwga2V5TmFtZT86IGtleW9mIFQgfCBzdHJpbmcgfCBzeW1ib2wsIGZvcmNlSGFyZEVycm9yPzogYm9vbGVhbikgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgbWFya1RhZ0FzQ29uc3VtZWQ6IHVuZGVmaW5lZCB8ICgoX3RhZzogVGFnKSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCBsb2dUcmFja2luZ1N0YWNrOiB1bmRlZmluZWQgfCAoKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IHN0cmluZyk7XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbiB7XG4gIHBhcmVudDogVHJhbnNhY3Rpb24gfCBudWxsO1xuICBkZWJ1Z0xhYmVsPzogc3RyaW5nO1xuICBkZXByZWNhdGU6IGJvb2xlYW47XG59XG5cbmlmIChERUJVRykge1xuICBsZXQgQ09OU1VNRURfVEFHUzogV2Vha01hcDxUYWcsIFRyYW5zYWN0aW9uPiB8IG51bGwgPSBudWxsO1xuXG4gIGxldCBUUkFOU0FDVElPTl9TVEFDSzogVHJhbnNhY3Rpb25bXSA9IFtdO1xuXG4gIC8vLy8vLy8vL1xuXG4gIGxldCBUUkFOU0FDVElPTl9FTlYgPSB7XG4gICAgYXNzZXJ0KG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0sXG5cbiAgICBkZXByZWNhdGUobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfSxcblxuICAgIGRlYnVnTWVzc2FnZShvYmo/OiB1bmtub3duLCBrZXlOYW1lPzogc3RyaW5nKSB7XG4gICAgICBsZXQgb2JqTmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqTmFtZSA9IG9iai5uYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IChvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUpIHx8ICcodW5rbm93biBjbGFzcyknO1xuXG4gICAgICAgIG9iak5hbWUgPSBgKGFuIGluc3RhbmNlIG9mICR7Y2xhc3NOYW1lfSlgO1xuICAgICAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmpOYW1lID0gJyhhbiB1bmtub3duIHRhZyknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqTmFtZSA9IFN0cmluZyhvYmopO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGlydHlTdHJpbmcgPSBrZXlOYW1lID8gYFxcYCR7a2V5TmFtZX1cXGAgb24gXFxgJHtvYmpOYW1lfVxcYGAgOiBgXFxgJHtvYmpOYW1lfVxcYGA7XG5cbiAgICAgIHJldHVybiBgWW91IGF0dGVtcHRlZCB0byB1cGRhdGUgJHtkaXJ0eVN0cmluZ30sIGJ1dCBpdCBoYWQgYWxyZWFkeSBiZWVuIHVzZWQgcHJldmlvdXNseSBpbiB0aGUgc2FtZSBjb21wdXRhdGlvbi4gIEF0dGVtcHRpbmcgdG8gdXBkYXRlIGEgdmFsdWUgYWZ0ZXIgdXNpbmcgaXQgaW4gYSBjb21wdXRhdGlvbiBjYW4gY2F1c2UgbG9naWNhbCBlcnJvcnMsIGluZmluaXRlIHJldmFsaWRhdGlvbiBidWdzLCBhbmQgcGVyZm9ybWFuY2UgaXNzdWVzLCBhbmQgaXMgbm90IHN1cHBvcnRlZC5gO1xuICAgIH0sXG4gIH07XG5cbiAgc2V0VHJhY2tpbmdUcmFuc2FjdGlvbkVudiA9IChlbnYpID0+IE9iamVjdC5hc3NpZ24oVFJBTlNBQ1RJT05fRU5WLCBlbnYpO1xuXG4gIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiA9IChfZGVidWdMYWJlbD86IHN0cmluZyB8IGZhbHNlLCBkZXByZWNhdGUgPSBmYWxzZSkgPT4ge1xuICAgIENPTlNVTUVEX1RBR1MgPSBDT05TVU1FRF9UQUdTIHx8IG5ldyBXZWFrTWFwKCk7XG5cbiAgICBsZXQgZGVidWdMYWJlbCA9IF9kZWJ1Z0xhYmVsIHx8IHVuZGVmaW5lZDtcblxuICAgIGxldCBwYXJlbnQgPSBUUkFOU0FDVElPTl9TVEFDS1tUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggLSAxXSB8fCBudWxsO1xuXG4gICAgVFJBTlNBQ1RJT05fU1RBQ0sucHVzaCh7XG4gICAgICBwYXJlbnQsXG4gICAgICBkZWJ1Z0xhYmVsLFxuICAgICAgZGVwcmVjYXRlLFxuICAgIH0pO1xuICB9O1xuXG4gIGVuZFRyYWNraW5nVHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgaWYgKFRSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0ZWQgdG8gY2xvc2UgYSB0cmFja2luZyB0cmFuc2FjdGlvbiwgYnV0IG9uZSB3YXMgbm90IG9wZW4nKTtcbiAgICB9XG5cbiAgICBUUkFOU0FDVElPTl9TVEFDSy5wb3AoKTtcblxuICAgIGlmIChUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggPT09IDApIHtcbiAgICAgIENPTlNVTUVEX1RBR1MgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXNldFRyYWNraW5nVHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgbGV0IHN0YWNrID0gJyc7XG5cbiAgICBpZiAoVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2sgPSBsb2dUcmFja2luZ1N0YWNrIShUUkFOU0FDVElPTl9TVEFDS1tUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggLSAxXSk7XG4gICAgfVxuXG4gICAgVFJBTlNBQ1RJT05fU1RBQ0sgPSBbXTtcbiAgICBDT05TVU1FRF9UQUdTID0gbnVsbDtcblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGdsb2JhbCBhdXRvdHJhY2tpbmcgdHJhbnNhY3Rpb24uIFRoaXMgd2lsbCBwcmV2ZW50IGFueSBiYWNrZmxvd1xuICAgKiBpbiBhbnkgYHRyYWNrYCBjYWxscyB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uLCBldmVuIGlmIHRoZXkgYXJlIG5vdFxuICAgKiBleHRlcm5hbGx5IGNvbnN1bWVkLlxuICAgKlxuICAgKiBgcnVuSW5BdXRvdHJhY2tpbmdUcmFuc2FjdGlvbmAgY2FuIGJlIGNhbGxlZCB3aXRoaW4gaXRzZWxmLCBhbmQgaXQgd2lsbCBhZGRcbiAgICogb250byB0aGUgZXhpc3RpbmcgdHJhbnNhY3Rpb24gaWYgb25lIGV4aXN0cy5cbiAgICpcbiAgICogVE9ETzogT25seSB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYHRyYWNrYCBpcyBjb25zdW1lZC5cbiAgICovXG4gIHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiA9IChmbjogKCkgPT4gdm9pZCwgZGVidWdMYWJlbD86IHN0cmluZyB8IGZhbHNlKSA9PiB7XG4gICAgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uIShkZWJ1Z0xhYmVsKTtcblxuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uISgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3dpdGNoZXMgdG8gZGVwcmVjYXRpbmcgd2l0aGluIGFuIGF1dG90cmFja2luZyB0cmFuc2FjdGlvbiwgaWYgb25lIGV4aXN0cy5cbiAgICogSWYgYHJ1bkluQXV0b3RyYWNraW5nVHJhbnNhY3Rpb25gIGlzIGNhbGxlZCB3aXRoaW4gdGhlIGNhbGxiYWNrIG9mIHRoaXNcbiAgICogbWV0aG9kLCBpdCBzd2l0Y2hlcyBiYWNrIHRvIHRocm93aW5nIGFuIGVycm9yLCBhbGxvd2luZyB6ZWJyYS1zdHJpcGluZyBvZlxuICAgKiB0aGUgdHlwZXMgb2YgZXJyb3JzIHRoYXQgYXJlIHRocm93bi5cbiAgICpcbiAgICogRG9lcyBub3Qgc3RhcnQgYW4gYXV0b3RyYWNraW5nIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBOT1RFOiBGb3IgRW1iZXIgdXNhZ2Ugb25seSwgaW4gZ2VuZXJhbCB5b3Ugc2hvdWxkIGFzc2VydCB0aGF0IHRoZXNlXG4gICAqIGludmFyaWFudHMgYXJlIHRydWUuXG4gICAqL1xuICBkZXByZWNhdGVNdXRhdGlvbnNJblRyYWNraW5nVHJhbnNhY3Rpb24gPSAoZm46ICgpID0+IHZvaWQsIGRlYnVnTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSkgPT4ge1xuICAgIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiEoZGVidWdMYWJlbCwgdHJ1ZSk7XG5cbiAgICB0cnkge1xuICAgICAgZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbiEoKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IG50aEluZGV4ID0gKHN0cjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcsIG46IG51bWJlciwgc3RhcnRpbmdQb3MgPSAtMSkgPT4ge1xuICAgIGxldCBpID0gc3RhcnRpbmdQb3M7XG5cbiAgICB3aGlsZSAobi0tID4gMCAmJiBpKysgPCBzdHIubGVuZ3RoKSB7XG4gICAgICBpID0gc3RyLmluZGV4T2YocGF0dGVybiwgaSk7XG4gICAgICBpZiAoaSA8IDApIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIGxldCBtYWtlVHJhY2tpbmdFcnJvck1lc3NhZ2UgPSA8VD4oXG4gICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLFxuICAgIG9iaj86IFQsXG4gICAga2V5TmFtZT86IGtleW9mIFQgfCBzdHJpbmcgfCBzeW1ib2xcbiAgKSA9PiB7XG4gICAgbGV0IG1lc3NhZ2UgPSBbVFJBTlNBQ1RJT05fRU5WLmRlYnVnTWVzc2FnZShvYmosIGtleU5hbWUgJiYgU3RyaW5nKGtleU5hbWUpKV07XG5cbiAgICBtZXNzYWdlLnB1c2goYFxcYCR7U3RyaW5nKGtleU5hbWUpfVxcYCB3YXMgZmlyc3QgdXNlZDpgKTtcblxuICAgIG1lc3NhZ2UucHVzaChsb2dUcmFja2luZ1N0YWNrISh0cmFuc2FjdGlvbikpO1xuXG4gICAgbWVzc2FnZS5wdXNoKGBTdGFjayB0cmFjZSBmb3IgdGhlIHVwZGF0ZTpgKTtcblxuICAgIHJldHVybiBtZXNzYWdlLmpvaW4oJ1xcblxcbicpO1xuICB9O1xuXG4gIGxvZ1RyYWNraW5nU3RhY2sgPSAodHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvbikgPT4ge1xuICAgIGxldCB0cmFja2luZ1N0YWNrID0gW107XG4gICAgbGV0IGN1cnJlbnQ6IFRyYW5zYWN0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZCA9XG4gICAgICB0cmFuc2FjdGlvbiB8fCBUUkFOU0FDVElPTl9TVEFDS1tUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcblxuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5kZWJ1Z0xhYmVsKSB7XG4gICAgICAgIHRyYWNraW5nU3RhY2sudW5zaGlmdChjdXJyZW50LmRlYnVnTGFiZWwpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFN0cmluZy5wcm90b3R5cGUucmVwZWF0IGhlcmUgb25jZSB3ZSBjYW4gZHJvcCBzdXBwb3J0IGZvciBJRTExXG4gICAgcmV0dXJuIHRyYWNraW5nU3RhY2subWFwKChsYWJlbCwgaW5kZXgpID0+IEFycmF5KDIgKiBpbmRleCArIDEpLmpvaW4oJyAnKSArIGxhYmVsKS5qb2luKCdcXG4nKTtcbiAgfTtcblxuICBtYXJrVGFnQXNDb25zdW1lZCA9IChfdGFnOiBUYWcpID0+IHtcbiAgICBpZiAoIUNPTlNVTUVEX1RBR1MgfHwgQ09OU1VNRURfVEFHUy5oYXMoX3RhZykpIHJldHVybjtcblxuICAgIENPTlNVTUVEX1RBR1Muc2V0KF90YWcsIFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gbWFyayB0aGUgdGFnIGFuZCBhbGwgb2YgaXRzIHN1YnRhZ3MgYXMgY29uc3VtZWQsIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBjYXN0IGl0IGFuZCBhY2Nlc3MgaXRzIGludGVybmFscy4gSW4gdGhlIGZ1dHVyZSB0aGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnksXG4gICAgLy8gdGhpcyBpcyBvbmx5IGZvciBjb21wdXRlZCBwcm9wZXJ0aWVzLlxuICAgIGxldCB0YWcgPSBfdGFnIGFzIGFueTtcblxuICAgIGlmICh0YWcuc3VidGFnKSB7XG4gICAgICBtYXJrVGFnQXNDb25zdW1lZCEodGFnLnN1YnRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHRhZy5zdWJ0YWdzKSB7XG4gICAgICB0YWcuc3VidGFncy5mb3JFYWNoKCh0YWc6IFRhZykgPT4gbWFya1RhZ0FzQ29uc3VtZWQhKHRhZykpO1xuICAgIH1cbiAgfTtcblxuICBhc3NlcnRUYWdOb3RDb25zdW1lZCA9IDxUPihcbiAgICB0YWc6IFRhZyxcbiAgICBvYmo/OiBULFxuICAgIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sLFxuICAgIGZvcmNlSGFyZEVycm9yOiBib29sZWFuIHwgdW5kZWZpbmVkID0gZmFsc2VcbiAgKSA9PiB7XG4gICAgaWYgKENPTlNVTUVEX1RBR1MgPT09IG51bGwpIHJldHVybjtcblxuICAgIGxldCB0cmFuc2FjdGlvbiA9IENPTlNVTUVEX1RBR1MuZ2V0KHRhZyk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uKSByZXR1cm47XG5cbiAgICBsZXQgY3VycmVudFRyYW5zYWN0aW9uID0gVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoY3VycmVudFRyYW5zYWN0aW9uLmRlcHJlY2F0ZSAmJiAhZm9yY2VIYXJkRXJyb3IpIHtcbiAgICAgIFRSQU5TQUNUSU9OX0VOVi5kZXByZWNhdGUobWFrZVRyYWNraW5nRXJyb3JNZXNzYWdlKHRyYW5zYWN0aW9uLCBvYmosIGtleU5hbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBoYWNrIG1ha2VzIHRoZSBhc3NlcnRpb24gbWVzc2FnZSBuaWNlciwgd2UgY2FuIGN1dCBvZmYgdGhlIGZpcnN0XG4gICAgICAvLyBmZXcgbGluZXMgb2YgdGhlIHN0YWNrIHRyYWNlIGFuZCBsZXQgdXNlcnMga25vdyB3aGVyZSB0aGUgYWN0dWFsIGVycm9yXG4gICAgICAvLyBvY2N1cnJlZC5cbiAgICAgIHRyeSB7XG4gICAgICAgIFRSQU5TQUNUSU9OX0VOVi5hc3NlcnQobWFrZVRyYWNraW5nRXJyb3JNZXNzYWdlKHRyYW5zYWN0aW9uLCBvYmosIGtleU5hbWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgICBsZXQgdXBkYXRlU3RhY2tCZWdpbiA9IGUuc3RhY2suaW5kZXhPZignU3RhY2sgdHJhY2UgZm9yIHRoZSB1cGRhdGU6Jyk7XG5cbiAgICAgICAgICBpZiAodXBkYXRlU3RhY2tCZWdpbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG50aEluZGV4KGUuc3RhY2ssICdcXG4nLCAxLCB1cGRhdGVTdGFja0JlZ2luKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBudGhJbmRleChlLnN0YWNrLCAnXFxuJywgNCwgdXBkYXRlU3RhY2tCZWdpbik7XG4gICAgICAgICAgICBlLnN0YWNrID0gZS5zdGFjay5zdWJzdHIoMCwgc3RhcnQpICsgZS5zdGFjay5zdWJzdHIoZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=