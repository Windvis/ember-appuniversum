import { DEBUG } from '@glimmer/env';
import { scheduleRevalidate } from '@glimmer/global-context';
import { symbol, unwrap } from './utils';
import { assertTagNotConsumed } from './debug';
export const CONSTANT = 0;
export const INITIAL = 1;
export const VOLATILE = NaN;
let $REVISION = INITIAL;
export function bump() {
  $REVISION++;
} //////////

export const COMPUTE = symbol('TAG_COMPUTE'); //////////

/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */

export function valueForTag(tag) {
  return tag[COMPUTE]();
}
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */

export function validateTag(tag, snapshot) {
  return snapshot >= tag[COMPUTE]();
}
const TYPE = symbol('TAG_TYPE'); // this is basically a const
// eslint-disable-next-line @typescript-eslint/naming-convention

export let ALLOW_CYCLES;

if (DEBUG) {
  ALLOW_CYCLES = new WeakMap();
}

function allowsCycles(tag) {
  if (ALLOW_CYCLES === undefined) {
    return true;
  } else {
    return ALLOW_CYCLES.has(tag);
  }
}

class MonomorphicTagImpl {
  constructor(type) {
    this.revision = INITIAL;
    this.lastChecked = INITIAL;
    this.lastValue = INITIAL;
    this.isUpdating = false;
    this.subtag = null;
    this.subtagBufferCache = null;
    this[TYPE] = type;
  }

  static combine(tags) {
    switch (tags.length) {
      case 0:
        return CONSTANT_TAG;

      case 1:
        return tags[0];

      default:
        let tag = new MonomorphicTagImpl(2
        /* Combinator */
        );
        tag.subtag = tags;
        return tag;
    }
  }

  [COMPUTE]() {
    let {
      lastChecked
    } = this;

    if (this.isUpdating === true) {
      if (DEBUG && !allowsCycles(this)) {
        throw new Error('Cycles in tags are not allowed');
      }

      this.lastChecked = ++$REVISION;
    } else if (lastChecked !== $REVISION) {
      this.isUpdating = true;
      this.lastChecked = $REVISION;

      try {
        let {
          subtag,
          revision
        } = this;

        if (subtag !== null) {
          if (Array.isArray(subtag)) {
            for (let i = 0; i < subtag.length; i++) {
              let value = subtag[i][COMPUTE]();
              revision = Math.max(value, revision);
            }
          } else {
            let subtagValue = subtag[COMPUTE]();

            if (subtagValue === this.subtagBufferCache) {
              revision = Math.max(revision, this.lastValue);
            } else {
              // Clear the temporary buffer cache
              this.subtagBufferCache = null;
              revision = Math.max(revision, subtagValue);
            }
          }
        }

        this.lastValue = revision;
      } finally {
        this.isUpdating = false;
      }
    }

    return this.lastValue;
  }

  static updateTag(_tag, _subtag) {
    if (DEBUG && _tag[TYPE] !== 1
    /* Updatable */
    ) {
        throw new Error('Attempted to update a tag that was not updatable');
      } // TODO: TS 3.7 should allow us to do this via assertion


    let tag = _tag;
    let subtag = _subtag;

    if (subtag === CONSTANT_TAG) {
      tag.subtag = null;
    } else {
      // There are two different possibilities when updating a subtag:
      //
      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();
      // 2. subtag[COMPUTE]() > tag[COMPUTE]();
      //
      // The first possibility is completely fine within our caching model, but
      // the second possibility presents a problem. If the parent tag has
      // already been read, then it's value is cached and will not update to
      // reflect the subtag's greater value. Next time the cache is busted, the
      // subtag's value _will_ be read, and it's value will be _greater_ than
      // the saved snapshot of the parent, causing the resulting calculation to
      // be rerun erroneously.
      //
      // In order to prevent this, when we first update to a new subtag we store
      // its computed value, and then check against that computed value on
      // subsequent updates. If its value hasn't changed, then we return the
      // parent's previous value. Once the subtag changes for the first time,
      // we clear the cache and everything is finally in sync with the parent.
      tag.subtagBufferCache = subtag[COMPUTE]();
      tag.subtag = subtag;
    }
  }

  static dirtyTag(tag) {
    if (DEBUG && !(tag[TYPE] === 1
    /* Updatable */
    || tag[TYPE] === 0
    /* Dirtyable */
    )) {
      throw new Error('Attempted to dirty a tag that was not dirtyable');
    }

    if (DEBUG) {
      // Usually by this point, we've already asserted with better error information,
      // but this is our last line of defense.
      unwrap(assertTagNotConsumed)(tag);
    }

    tag.revision = ++$REVISION;
    scheduleRevalidate();
  }

}

export const DIRTY_TAG = MonomorphicTagImpl.dirtyTag;
export const UPDATE_TAG = MonomorphicTagImpl.updateTag; //////////

export function createTag() {
  return new MonomorphicTagImpl(0
  /* Dirtyable */
  );
}
export function createUpdatableTag() {
  return new MonomorphicTagImpl(1
  /* Updatable */
  );
} //////////

export const CONSTANT_TAG = new MonomorphicTagImpl(3
/* Constant */
);
export function isConstTag(tag) {
  return tag === CONSTANT_TAG;
} //////////

export class VolatileTag {
  [COMPUTE]() {
    return VOLATILE;
  }

}
export const VOLATILE_TAG = new VolatileTag(); //////////

export class CurrentTag {
  [COMPUTE]() {
    return $REVISION;
  }

}
export const CURRENT_TAG = new CurrentTag(); //////////

export const combine = MonomorphicTagImpl.combine; // Warm

let tag1 = createUpdatableTag();
let tag2 = createUpdatableTag();
let tag3 = createUpdatableTag();
valueForTag(tag1);
DIRTY_TAG(tag1);
valueForTag(tag1);
UPDATE_TAG(tag1, combine([tag2, tag3]));
valueForTag(tag1);
DIRTY_TAG(tag2);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
UPDATE_TAG(tag1, tag3);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQVQsUUFBc0IsY0FBdEI7QUFDQSxTQUFTLGtCQUFULFFBQW1DLHlCQUFuQztBQUNBLFNBQVMsTUFBVCxFQUFpQixNQUFqQixRQUErQixTQUEvQjtBQUNBLFNBQVMsb0JBQVQsUUFBcUMsU0FBckM7QUFNQSxPQUFPLE1BQU0sUUFBUSxHQUFhLENBQTNCO0FBQ1AsT0FBTyxNQUFNLE9BQU8sR0FBYSxDQUExQjtBQUNQLE9BQU8sTUFBTSxRQUFRLEdBQWEsR0FBM0I7QUFFUCxJQUFJLFNBQVMsR0FBRyxPQUFoQjtBQUVBLE9BQU0sU0FBVSxJQUFWLEdBQWM7QUFDbEIsRUFBQSxTQUFTO0FBQ1YsQyxDQUVEOztBQUVBLE9BQU8sTUFBTSxPQUFPLEdBQWtCLE1BQU0sQ0FBQyxhQUFELENBQXJDLEMsQ0FRUDs7QUFFQTs7Ozs7Ozs7O0FBUUEsT0FBTSxTQUFVLFdBQVYsQ0FBc0IsR0FBdEIsRUFBOEI7QUFDbEMsU0FBTyxHQUFHLENBQUMsT0FBRCxDQUFILEVBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7OztBQVVBLE9BQU0sU0FBVSxXQUFWLENBQXNCLEdBQXRCLEVBQWdDLFFBQWhDLEVBQWtEO0FBQ3RELFNBQU8sUUFBUSxJQUFJLEdBQUcsQ0FBQyxPQUFELENBQUgsRUFBbkI7QUFDRDtBQWlCRCxNQUFNLElBQUksR0FBa0IsTUFBTSxDQUFDLFVBQUQsQ0FBbEMsQyxDQUVBO0FBQ0E7O0FBQ0EsT0FBTyxJQUFJLFlBQUo7O0FBRVAsSUFBSSxLQUFKLEVBQVc7QUFDVCxFQUFBLFlBQVksR0FBRyxJQUFJLE9BQUosRUFBZjtBQUNEOztBQUVELFNBQVMsWUFBVCxDQUFzQixHQUF0QixFQUE4QjtBQUM1QixNQUFJLFlBQVksS0FBSyxTQUFyQixFQUFnQztBQUM5QixXQUFPLElBQVA7QUFDRCxHQUZELE1B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LElBQUQsQ0FBVDtBQUNBLFdBQVcsQ0FBQyxJQUFELENBQVgiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBzY2hlZHVsZVJldmFsaWRhdGUgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBzeW1ib2wsIHVud3JhcCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgYXNzZXJ0VGFnTm90Q29uc3VtZWQgfSBmcm9tICcuL2RlYnVnJztcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSBSZXZpc2lvbiA9IG51bWJlcjtcblxuZXhwb3J0IGNvbnN0IENPTlNUQU5UOiBSZXZpc2lvbiA9IDA7XG5leHBvcnQgY29uc3QgSU5JVElBTDogUmV2aXNpb24gPSAxO1xuZXhwb3J0IGNvbnN0IFZPTEFUSUxFOiBSZXZpc2lvbiA9IE5hTjtcblxubGV0ICRSRVZJU0lPTiA9IElOSVRJQUw7XG5cbmV4cG9ydCBmdW5jdGlvbiBidW1wKCk6IHZvaWQge1xuICAkUkVWSVNJT04rKztcbn1cblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgQ09NUFVURTogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnVEFHX0NPTVBVVEUnKTtcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlUYWc8VD4ge1xuICBbQ09NUFVURV0oKTogVDtcbn1cblxuZXhwb3J0IHR5cGUgVGFnID0gRW50aXR5VGFnPFJldmlzaW9uPjtcblxuLy8vLy8vLy8vL1xuXG4vKipcbiAqIGB2YWx1ZWAgcmVjZWl2ZXMgYSB0YWcgYW5kIHJldHVybnMgYW4gb3BhcXVlIFJldmlzaW9uIGJhc2VkIG9uIHRoYXQgdGFnLiBUaGlzXG4gKiBzbmFwc2hvdCBjYW4gdGhlbiBsYXRlciBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCB3aXRoIHRoZSBzYW1lIHRhZyB0b1xuICogZGV0ZXJtaW5lIGlmIHRoZSB0YWcgaGFzIGNoYW5nZWQgYXQgYWxsIHNpbmNlIHRoZSB0aW1lIHRoYXQgYHZhbHVlYCB3YXNcbiAqIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZUZvclRhZyh0YWc6IFRhZyk6IFJldmlzaW9uIHtcbiAgcmV0dXJuIHRhZ1tDT01QVVRFXSgpO1xufVxuXG4vKipcbiAqIGB2YWxpZGF0ZWAgcmVjZWl2ZXMgYSB0YWcgYW5kIGEgc25hcHNob3QgZnJvbSBhIHByZXZpb3VzIGNhbGwgdG8gYHZhbHVlYCB3aXRoXG4gKiB0aGUgc2FtZSB0YWcsIGFuZCBkZXRlcm1pbmVzIGlmIHRoZSB0YWcgaXMgc3RpbGwgdmFsaWQgY29tcGFyZWQgdG8gdGhlXG4gKiBzbmFwc2hvdC4gSWYgdGhlIHRhZydzIHN0YXRlIGhhcyBjaGFuZ2VkIGF0IGFsbCBzaW5jZSB0aGVuLCBgdmFsaWRhdGVgIHdpbGxcbiAqIHJldHVybiBmYWxzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIHRydWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYVxuICogY2FsY3VsYXRpb24gcmVsYXRlZCB0byB0aGUgdGFncyBzaG91bGQgYmUgcmVydW4uXG4gKlxuICogQHBhcmFtIHRhZ1xuICogQHBhcmFtIHNuYXBzaG90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRhZyh0YWc6IFRhZywgc25hcHNob3Q6IFJldmlzaW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBzbmFwc2hvdCA+PSB0YWdbQ09NUFVURV0oKTtcbn1cblxuLy8vLy8vLy8vL1xuXG4vKipcbiAqIFRoaXMgZW51bSByZXByZXNlbnRzIGFsbCBvZiB0aGUgcG9zc2libGUgdGFnIHR5cGVzIGZvciB0aGUgbW9ub21vcnBoaWMgdGFnIGNsYXNzLlxuICogT3RoZXIgY3VzdG9tIHRhZyBjbGFzc2VzIGNhbiBleGlzdCwgc3VjaCBhcyBDdXJyZW50VGFnIGFuZCBWb2xhdGlsZVRhZywgYnV0IGZvclxuICogcGVyZm9ybWFuY2UgcmVhc29ucywgYW55IHR5cGUgb2YgdGFnIHRoYXQgaXMgbWVhbnQgdG8gYmUgdXNlZCBmcmVxdWVudGx5IHNob3VsZFxuICogYmUgYWRkZWQgdG8gdGhlIG1vbm9tb3JwaGljIHRhZy5cbiAqL1xuY29uc3QgZW51bSBNb25vbW9ycGhpY1RhZ1R5cGVzIHtcbiAgRGlydHlhYmxlLFxuICBVcGRhdGFibGUsXG4gIENvbWJpbmF0b3IsXG4gIENvbnN0YW50LFxufVxuXG5jb25zdCBUWVBFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUQUdfVFlQRScpO1xuXG4vLyB0aGlzIGlzIGJhc2ljYWxseSBhIGNvbnN0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgbGV0IEFMTE9XX0NZQ0xFUzogV2Vha01hcDxUYWcsIGJvb2xlYW4+IHwgdW5kZWZpbmVkO1xuXG5pZiAoREVCVUcpIHtcbiAgQUxMT1dfQ1lDTEVTID0gbmV3IFdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gYWxsb3dzQ3ljbGVzKHRhZzogVGFnKTogYm9vbGVhbiB7XG4gIGlmIChBTExPV19DWUNMRVMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBTExPV19DWUNMRVMuaGFzKHRhZyk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIE1vbm9tb3JwaGljVGFnQmFzZTxUIGV4dGVuZHMgTW9ub21vcnBoaWNUYWdUeXBlcz4gZXh0ZW5kcyBUYWcge1xuICBbVFlQRV06IFQ7XG59XG5cbmV4cG9ydCB0eXBlIERpcnR5YWJsZVRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZT47XG5leHBvcnQgdHlwZSBVcGRhdGFibGVUYWcgPSBNb25vbW9ycGhpY1RhZ0Jhc2U8TW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGU+O1xuZXhwb3J0IHR5cGUgQ29tYmluYXRvclRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbWJpbmF0b3I+O1xuZXhwb3J0IHR5cGUgQ29uc3RhbnRUYWcgPSBNb25vbW9ycGhpY1RhZ0Jhc2U8TW9ub21vcnBoaWNUYWdUeXBlcy5Db25zdGFudD47XG5cbmNsYXNzIE1vbm9tb3JwaGljVGFnSW1wbDxUIGV4dGVuZHMgTW9ub21vcnBoaWNUYWdUeXBlcyA9IE1vbm9tb3JwaGljVGFnVHlwZXM+IHtcbiAgc3RhdGljIGNvbWJpbmUodGFnczogVGFnW10pOiBUYWcge1xuICAgIHN3aXRjaCAodGFncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIENPTlNUQU5UX1RBRztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRhZ3NbMF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZXQgdGFnOiBNb25vbW9ycGhpY1RhZ0ltcGwgPSBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuQ29tYmluYXRvcik7XG4gICAgICAgIHRhZy5zdWJ0YWcgPSB0YWdzO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIHJldmlzaW9uID0gSU5JVElBTDtcbiAgcHJpdmF0ZSBsYXN0Q2hlY2tlZCA9IElOSVRJQUw7XG4gIHByaXZhdGUgbGFzdFZhbHVlID0gSU5JVElBTDtcblxuICBwcml2YXRlIGlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdWJ0YWc6IFRhZyB8IFRhZ1tdIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3VidGFnQnVmZmVyQ2FjaGU6IFJldmlzaW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgW1RZUEVdOiBUO1xuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IFQpIHtcbiAgICB0aGlzW1RZUEVdID0gdHlwZTtcbiAgfVxuXG4gIFtDT01QVVRFXSgpOiBSZXZpc2lvbiB7XG4gICAgbGV0IHsgbGFzdENoZWNrZWQgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc1VwZGF0aW5nID09PSB0cnVlKSB7XG4gICAgICBpZiAoREVCVUcgJiYgIWFsbG93c0N5Y2xlcyh0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N5Y2xlcyBpbiB0YWdzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RDaGVja2VkID0gKyskUkVWSVNJT047XG4gICAgfSBlbHNlIGlmIChsYXN0Q2hlY2tlZCAhPT0gJFJFVklTSU9OKSB7XG4gICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5sYXN0Q2hlY2tlZCA9ICRSRVZJU0lPTjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHsgc3VidGFnLCByZXZpc2lvbiB9ID0gdGhpcztcblxuICAgICAgICBpZiAoc3VidGFnICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3VidGFnKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJ0YWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gc3VidGFnW2ldW0NPTVBVVEVdKCk7XG4gICAgICAgICAgICAgIHJldmlzaW9uID0gTWF0aC5tYXgodmFsdWUsIHJldmlzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN1YnRhZ1ZhbHVlID0gc3VidGFnW0NPTVBVVEVdKCk7XG5cbiAgICAgICAgICAgIGlmIChzdWJ0YWdWYWx1ZSA9PT0gdGhpcy5zdWJ0YWdCdWZmZXJDYWNoZSkge1xuICAgICAgICAgICAgICByZXZpc2lvbiA9IE1hdGgubWF4KHJldmlzaW9uLCB0aGlzLmxhc3RWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgdGVtcG9yYXJ5IGJ1ZmZlciBjYWNoZVxuICAgICAgICAgICAgICB0aGlzLnN1YnRhZ0J1ZmZlckNhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV2aXNpb24gPSBNYXRoLm1heChyZXZpc2lvbiwgc3VidGFnVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gcmV2aXNpb247XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sYXN0VmFsdWU7XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlVGFnKF90YWc6IFVwZGF0YWJsZVRhZywgX3N1YnRhZzogVGFnKSB7XG4gICAgaWYgKERFQlVHICYmIF90YWdbVFlQRV0gIT09IE1vbm9tb3JwaGljVGFnVHlwZXMuVXBkYXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1cGRhdGUgYSB0YWcgdGhhdCB3YXMgbm90IHVwZGF0YWJsZScpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFRTIDMuNyBzaG91bGQgYWxsb3cgdXMgdG8gZG8gdGhpcyB2aWEgYXNzZXJ0aW9uXG4gICAgbGV0IHRhZyA9IF90YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsO1xuICAgIGxldCBzdWJ0YWcgPSBfc3VidGFnIGFzIE1vbm9tb3JwaGljVGFnSW1wbDtcblxuICAgIGlmIChzdWJ0YWcgPT09IENPTlNUQU5UX1RBRykge1xuICAgICAgdGFnLnN1YnRhZyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGFyZSB0d28gZGlmZmVyZW50IHBvc3NpYmlsaXRpZXMgd2hlbiB1cGRhdGluZyBhIHN1YnRhZzpcbiAgICAgIC8vXG4gICAgICAvLyAxLiBzdWJ0YWdbQ09NUFVURV0oKSA8PSB0YWdbQ09NUFVURV0oKTtcbiAgICAgIC8vIDIuIHN1YnRhZ1tDT01QVVRFXSgpID4gdGFnW0NPTVBVVEVdKCk7XG4gICAgICAvL1xuICAgICAgLy8gVGhlIGZpcnN0IHBvc3NpYmlsaXR5IGlzIGNvbXBsZXRlbHkgZmluZSB3aXRoaW4gb3VyIGNhY2hpbmcgbW9kZWwsIGJ1dFxuICAgICAgLy8gdGhlIHNlY29uZCBwb3NzaWJpbGl0eSBwcmVzZW50cyBhIHByb2JsZW0uIElmIHRoZSBwYXJlbnQgdGFnIGhhc1xuICAgICAgLy8gYWxyZWFkeSBiZWVuIHJlYWQsIHRoZW4gaXQncyB2YWx1ZSBpcyBjYWNoZWQgYW5kIHdpbGwgbm90IHVwZGF0ZSB0b1xuICAgICAgLy8gcmVmbGVjdCB0aGUgc3VidGFnJ3MgZ3JlYXRlciB2YWx1ZS4gTmV4dCB0aW1lIHRoZSBjYWNoZSBpcyBidXN0ZWQsIHRoZVxuICAgICAgLy8gc3VidGFnJ3MgdmFsdWUgX3dpbGxfIGJlIHJlYWQsIGFuZCBpdCdzIHZhbHVlIHdpbGwgYmUgX2dyZWF0ZXJfIHRoYW5cbiAgICAgIC8vIHRoZSBzYXZlZCBzbmFwc2hvdCBvZiB0aGUgcGFyZW50LCBjYXVzaW5nIHRoZSByZXN1bHRpbmcgY2FsY3VsYXRpb24gdG9cbiAgICAgIC8vIGJlIHJlcnVuIGVycm9uZW91c2x5LlxuICAgICAgLy9cbiAgICAgIC8vIEluIG9yZGVyIHRvIHByZXZlbnQgdGhpcywgd2hlbiB3ZSBmaXJzdCB1cGRhdGUgdG8gYSBuZXcgc3VidGFnIHdlIHN0b3JlXG4gICAgICAvLyBpdHMgY29tcHV0ZWQgdmFsdWUsIGFuZCB0aGVuIGNoZWNrIGFnYWluc3QgdGhhdCBjb21wdXRlZCB2YWx1ZSBvblxuICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLiBJZiBpdHMgdmFsdWUgaGFzbid0IGNoYW5nZWQsIHRoZW4gd2UgcmV0dXJuIHRoZVxuICAgICAgLy8gcGFyZW50J3MgcHJldmlvdXMgdmFsdWUuIE9uY2UgdGhlIHN1YnRhZyBjaGFuZ2VzIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAgIC8vIHdlIGNsZWFyIHRoZSBjYWNoZSBhbmQgZXZlcnl0aGluZyBpcyBmaW5hbGx5IGluIHN5bmMgd2l0aCB0aGUgcGFyZW50LlxuICAgICAgdGFnLnN1YnRhZ0J1ZmZlckNhY2hlID0gc3VidGFnW0NPTVBVVEVdKCk7XG4gICAgICB0YWcuc3VidGFnID0gc3VidGFnO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkaXJ0eVRhZyh0YWc6IERpcnR5YWJsZVRhZyB8IFVwZGF0YWJsZVRhZykge1xuICAgIGlmIChcbiAgICAgIERFQlVHICYmXG4gICAgICAhKHRhZ1tUWVBFXSA9PT0gTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUgfHwgdGFnW1RZUEVdID09PSBNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGRpcnR5IGEgdGFnIHRoYXQgd2FzIG5vdCBkaXJ0eWFibGUnKTtcbiAgICB9XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIC8vIFVzdWFsbHkgYnkgdGhpcyBwb2ludCwgd2UndmUgYWxyZWFkeSBhc3NlcnRlZCB3aXRoIGJldHRlciBlcnJvciBpbmZvcm1hdGlvbixcbiAgICAgIC8vIGJ1dCB0aGlzIGlzIG91ciBsYXN0IGxpbmUgb2YgZGVmZW5zZS5cbiAgICAgIHVud3JhcChhc3NlcnRUYWdOb3RDb25zdW1lZCkodGFnKTtcbiAgICB9XG5cbiAgICAodGFnIGFzIE1vbm9tb3JwaGljVGFnSW1wbCkucmV2aXNpb24gPSArKyRSRVZJU0lPTjtcblxuICAgIHNjaGVkdWxlUmV2YWxpZGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBESVJUWV9UQUcgPSBNb25vbW9ycGhpY1RhZ0ltcGwuZGlydHlUYWc7XG5leHBvcnQgY29uc3QgVVBEQVRFX1RBRyA9IE1vbm9tb3JwaGljVGFnSW1wbC51cGRhdGVUYWc7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhZygpOiBEaXJ0eWFibGVUYWcge1xuICByZXR1cm4gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVVcGRhdGFibGVUYWcoKTogVXBkYXRhYmxlVGFnIHtcbiAgcmV0dXJuIG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT05TVEFOVF9UQUc6IENvbnN0YW50VGFnID0gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbnN0YW50KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3RUYWcodGFnOiBUYWcpOiB0YWcgaXMgQ29uc3RhbnRUYWcge1xuICByZXR1cm4gdGFnID09PSBDT05TVEFOVF9UQUc7XG59XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNsYXNzIFZvbGF0aWxlVGFnIGltcGxlbWVudHMgVGFnIHtcbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICByZXR1cm4gVk9MQVRJTEU7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFZPTEFUSUxFX1RBRyA9IG5ldyBWb2xhdGlsZVRhZygpO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjbGFzcyBDdXJyZW50VGFnIGltcGxlbWVudHMgQ3VycmVudFRhZyB7XG4gIFtDT01QVVRFXSgpOiBSZXZpc2lvbiB7XG4gICAgcmV0dXJuICRSRVZJU0lPTjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ1VSUkVOVF9UQUcgPSBuZXcgQ3VycmVudFRhZygpO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBjb21iaW5lID0gTW9ub21vcnBoaWNUYWdJbXBsLmNvbWJpbmU7XG5cbi8vIFdhcm1cblxubGV0IHRhZzEgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbmxldCB0YWcyID0gY3JlYXRlVXBkYXRhYmxlVGFnKCk7XG5sZXQgdGFnMyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuXG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWcxKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuVVBEQVRFX1RBRyh0YWcxLCBjb21iaW5lKFt0YWcyLCB0YWczXSkpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5ESVJUWV9UQUcodGFnMik7XG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWczKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuVVBEQVRFX1RBRyh0YWcxLCB0YWczKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzMpO1xudmFsdWVGb3JUYWcodGFnMSk7XG4iXSwic291cmNlUm9vdCI6IiJ9