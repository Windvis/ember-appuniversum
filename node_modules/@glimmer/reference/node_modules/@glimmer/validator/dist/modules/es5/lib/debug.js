import { DEBUG } from '@glimmer/env';
export var beginTrackingTransaction;
export var endTrackingTransaction;
export var runInTrackingTransaction;
export var deprecateMutationsInTrackingTransaction;
export var resetTrackingTransaction;
export var setTrackingTransactionEnv;
export var assertTagNotConsumed;

var _markTagAsConsumed;

export { _markTagAsConsumed as markTagAsConsumed };
export var logTrackingStack;

if (DEBUG) {
  var CONSUMED_TAGS = null;
  var TRANSACTION_STACK = []; /////////

  var TRANSACTION_ENV = {
    assert: function assert(message) {
      throw new Error(message);
    },
    deprecate: function deprecate(message) {
      console.warn(message);
    },
    debugMessage: function debugMessage(obj, keyName) {
      var objName;

      if (typeof obj === 'function') {
        objName = obj.name;
      } else if (typeof obj === 'object' && obj !== null) {
        var className = obj.constructor && obj.constructor.name || '(unknown class)';
        objName = "(an instance of " + className + ")";
      } else if (obj === undefined) {
        objName = '(an unknown tag)';
      } else {
        objName = String(obj);
      }

      var dirtyString = keyName ? "`" + keyName + "` on `" + objName + "`" : "`" + objName + "`";
      return "You attempted to update " + dirtyString + ", but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.";
    }
  };

  setTrackingTransactionEnv = function setTrackingTransactionEnv(env) {
    return Object.assign(TRANSACTION_ENV, env);
  };

  beginTrackingTransaction = function beginTrackingTransaction(_debugLabel, deprecate) {
    if (deprecate === void 0) {
      deprecate = false;
    }

    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();
    var debugLabel = _debugLabel || undefined;
    var parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] || null;
    TRANSACTION_STACK.push({
      parent: parent,
      debugLabel: debugLabel,
      deprecate: deprecate
    });
  };

  endTrackingTransaction = function endTrackingTransaction() {
    if (TRANSACTION_STACK.length === 0) {
      throw new Error('attempted to close a tracking transaction, but one was not open');
    }

    TRANSACTION_STACK.pop();

    if (TRANSACTION_STACK.length === 0) {
      CONSUMED_TAGS = null;
    }
  };

  resetTrackingTransaction = function resetTrackingTransaction() {
    var stack = '';

    if (TRANSACTION_STACK.length > 0) {
      stack = logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);
    }

    TRANSACTION_STACK = [];
    CONSUMED_TAGS = null;
    return stack;
  };
  /**
   * Creates a global autotracking transaction. This will prevent any backflow
   * in any `track` calls within the transaction, even if they are not
   * externally consumed.
   *
   * `runInAutotrackingTransaction` can be called within itself, and it will add
   * onto the existing transaction if one exists.
   *
   * TODO: Only throw an error if the `track` is consumed.
   */


  runInTrackingTransaction = function runInTrackingTransaction(fn, debugLabel) {
    beginTrackingTransaction(debugLabel);

    try {
      fn();
    } finally {
      endTrackingTransaction();
    }
  };
  /**
   * Switches to deprecating within an autotracking transaction, if one exists.
   * If `runInAutotrackingTransaction` is called within the callback of this
   * method, it switches back to throwing an error, allowing zebra-striping of
   * the types of errors that are thrown.
   *
   * Does not start an autotracking transaction.
   *
   * NOTE: For Ember usage only, in general you should assert that these
   * invariants are true.
   */


  deprecateMutationsInTrackingTransaction = function deprecateMutationsInTrackingTransaction(fn, debugLabel) {
    beginTrackingTransaction(debugLabel, true);

    try {
      fn();
    } finally {
      endTrackingTransaction();
    }
  };

  var nthIndex = function nthIndex(str, pattern, n, startingPos) {
    if (startingPos === void 0) {
      startingPos = -1;
    }

    var i = startingPos;

    while (n-- > 0 && i++ < str.length) {
      i = str.indexOf(pattern, i);
      if (i < 0) break;
    }

    return i;
  };

  var makeTrackingErrorMessage = function makeTrackingErrorMessage(transaction, obj, keyName) {
    var message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    message.push("`" + String(keyName) + "` was first used:");
    message.push(logTrackingStack(transaction));
    message.push("Stack trace for the update:");
    return message.join('\n\n');
  };

  logTrackingStack = function logTrackingStack(transaction) {
    var trackingStack = [];
    var current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (current === undefined) return '';

    while (current) {
      if (current.debugLabel) {
        trackingStack.unshift(current.debugLabel);
      }

      current = current.parent;
    } // TODO: Use String.prototype.repeat here once we can drop support for IE11


    return trackingStack.map(function (label, index) {
      return Array(2 * index + 1).join(' ') + label;
    }).join('\n');
  };

  _markTagAsConsumed = function markTagAsConsumed(_tag) {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    CONSUMED_TAGS.set(_tag, TRANSACTION_STACK[TRANSACTION_STACK.length - 1]); // We need to mark the tag and all of its subtags as consumed, so we need to
    // cast it and access its internals. In the future this shouldn't be necessary,
    // this is only for computed properties.

    var tag = _tag;

    if (tag.subtag) {
      _markTagAsConsumed(tag.subtag);
    }

    if (tag.subtags) {
      tag.subtags.forEach(function (tag) {
        return _markTagAsConsumed(tag);
      });
    }
  };

  assertTagNotConsumed = function assertTagNotConsumed(tag, obj, keyName, forceHardError) {
    if (forceHardError === void 0) {
      forceHardError = false;
    }

    if (CONSUMED_TAGS === null) return;
    var transaction = CONSUMED_TAGS.get(tag);
    if (!transaction) return;
    var currentTransaction = TRANSACTION_STACK[TRANSACTION_STACK.length - 1];

    if (currentTransaction.deprecate && !forceHardError) {
      TRANSACTION_ENV.deprecate(makeTrackingErrorMessage(transaction, obj, keyName));
    } else {
      // This hack makes the assertion message nicer, we can cut off the first
      // few lines of the stack trace and let users know where the actual error
      // occurred.
      try {
        TRANSACTION_ENV.assert(makeTrackingErrorMessage(transaction, obj, keyName));
      } catch (e) {
        if (e.stack) {
          var updateStackBegin = e.stack.indexOf('Stack trace for the update:');

          if (updateStackBegin !== -1) {
            var start = nthIndex(e.stack, '\n', 1, updateStackBegin);
            var end = nthIndex(e.stack, '\n', 4, updateStackBegin);
            e.stack = e.stack.substr(0, start) + e.stack.substr(end);
          }
        }

        throw e;
      }
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsU0FBQSxLQUFBLFFBQUEsY0FBQTtBQUVBLE9BQU8sSUFBQSx3QkFBQTtBQUdQLE9BQU8sSUFBQSxzQkFBQTtBQUNQLE9BQU8sSUFBQSx3QkFBQTtBQUdQLE9BQU8sSUFBQSx1Q0FBQTtBQUVQLE9BQU8sSUFBQSx3QkFBQTtBQUNQLE9BQU8sSUFBQSx5QkFBQTtBQVFQLE9BQU8sSUFBQSxvQkFBQTs7QUFJQSxJQUFBLGtCQUFBOzs7QUFFUCxPQUFPLElBQUEsZ0JBQUE7O0FBUVAsSUFBQSxLQUFBLEVBQVc7QUFDVCxNQUFJLGFBQWEsR0FBakIsSUFBQTtBQUVBLE1BQUksaUJBQWlCLEdBSFosRUFHVCxDQUhTLENBS1Q7O0FBRUEsTUFBSSxlQUFlLEdBQUc7QUFDcEIsSUFBQSxNQURvQixrQkFDZCxPQURjLEVBQ0U7QUFDcEIsWUFBTSxJQUFBLEtBQUEsQ0FBTixPQUFNLENBQU47QUFGa0IsS0FBQTtBQUtwQixJQUFBLFNBTG9CLHFCQUtYLE9BTFcsRUFLSztBQUN2QixNQUFBLE9BQU8sQ0FBUCxJQUFBLENBQUEsT0FBQTtBQU5rQixLQUFBO0FBU3BCLElBQUEsWUFUb0Isd0JBU1IsR0FUUSxFQVNSLE9BVFEsRUFTd0I7QUFDMUMsVUFBQSxPQUFBOztBQUVBLFVBQUksT0FBQSxHQUFBLEtBQUosVUFBQSxFQUErQjtBQUM3QixRQUFBLE9BQU8sR0FBRyxHQUFHLENBQWIsSUFBQTtBQURGLE9BQUEsTUFFTyxJQUFJLE9BQUEsR0FBQSxLQUFBLFFBQUEsSUFBMkIsR0FBRyxLQUFsQyxJQUFBLEVBQTZDO0FBQ2xELFlBQUksU0FBUyxHQUFJLEdBQUcsQ0FBSCxXQUFBLElBQW1CLEdBQUcsQ0FBSCxXQUFBLENBQXBCLElBQUMsSUFBakIsaUJBQUE7QUFFQSxRQUFBLE9BQU8sd0JBQVAsU0FBTyxNQUFQO0FBSEssT0FBQSxNQUlBLElBQUksR0FBRyxLQUFQLFNBQUEsRUFBdUI7QUFDNUIsUUFBQSxPQUFPLEdBQVAsa0JBQUE7QUFESyxPQUFBLE1BRUE7QUFDTCxRQUFBLE9BQU8sR0FBRyxNQUFNLENBQWhCLEdBQWdCLENBQWhCO0FBQ0Q7O0FBRUQsVUFBSSxXQUFXLEdBQUcsT0FBTyxTQUFRLE9BQVIsY0FBQSxPQUFBLGVBQXpCLE9BQXlCLE1BQXpCO0FBRUEsMENBQUEsV0FBQTtBQUNEO0FBM0JtQixHQUF0Qjs7QUE4QkEsRUFBQSx5QkFBeUIsR0FBSSxtQ0FBQSxHQUFEO0FBQUEsV0FBUyxNQUFNLENBQU4sTUFBQSxDQUFBLGVBQUEsRUFBckMsR0FBcUMsQ0FBVDtBQUFBLEdBQTVCOztBQUVBLEVBQUEsd0JBQXdCLEdBQUcsa0NBQUEsV0FBQSxFQUErQixTQUEvQixFQUFvRDtBQUFBLFFBQXJCLFNBQXFCO0FBQXJCLE1BQUEsU0FBcUIsR0FBcEQsS0FBb0Q7QUFBQTs7QUFDN0UsSUFBQSxhQUFhLEdBQUcsYUFBYSxJQUFJLElBQWpDLE9BQWlDLEVBQWpDO0FBRUEsUUFBSSxVQUFVLEdBQUcsV0FBVyxJQUE1QixTQUFBO0FBRUEsUUFBSSxNQUFNLEdBQUcsaUJBQWlCLENBQUMsaUJBQWlCLENBQWpCLE1BQUEsR0FBbEIsQ0FBaUIsQ0FBakIsSUFBYixJQUFBO0FBRUEsSUFBQSxpQkFBaUIsQ0FBakIsSUFBQSxDQUF1QjtBQUNyQixNQUFBLE1BRHFCLEVBQ3JCLE1BRHFCO0FBRXJCLE1BQUEsVUFGcUIsRUFFckIsVUFGcUI7QUFHckIsTUFBQSxTQUFBLEVBQUE7QUFIcUIsS0FBdkI7QUFQRixHQUFBOztBQWNBLEVBQUEsc0JBQXNCLEdBQUcsa0NBQUs7QUFDNUIsUUFBSSxpQkFBaUIsQ0FBakIsTUFBQSxLQUFKLENBQUEsRUFBb0M7QUFDbEMsWUFBTSxJQUFBLEtBQUEsQ0FBTixpRUFBTSxDQUFOO0FBQ0Q7O0FBRUQsSUFBQSxpQkFBaUIsQ0FBakIsR0FBQTs7QUFFQSxRQUFJLGlCQUFpQixDQUFqQixNQUFBLEtBQUosQ0FBQSxFQUFvQztBQUNsQyxNQUFBLGFBQWEsR0FBYixJQUFBO0FBQ0Q7QUFUSCxHQUFBOztBQVlBLEVBQUEsd0JBQXdCLEdBQUcsb0NBQUs7QUFDOUIsUUFBSSxLQUFLLEdBQVQsRUFBQTs7QUFFQSxRQUFJLGlCQUFpQixDQUFqQixNQUFBLEdBQUosQ0FBQSxFQUFrQztBQUNoQyxNQUFBLEtBQUssR0FBRyxnQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBakIsTUFBQSxHQUE1QyxDQUEyQyxDQUFsQixDQUF6QjtBQUNEOztBQUVELElBQUEsaUJBQWlCLEdBQWpCLEVBQUE7QUFDQSxJQUFBLGFBQWEsR0FBYixJQUFBO0FBRUEsV0FBQSxLQUFBO0FBVkYsR0FBQTtBQWFBOzs7Ozs7Ozs7Ozs7QUFVQSxFQUFBLHdCQUF3QixHQUFHLGtDQUFBLEVBQUEsRUFBQSxVQUFBLEVBQWdEO0FBQ3pFLElBQUEsd0JBQXlCLENBQXpCLFVBQXlCLENBQXpCOztBQUVBLFFBQUk7QUFDRixNQUFBLEVBQUU7QUFESixLQUFBLFNBRVU7QUFDUixNQUFBLHNCQUF1QjtBQUN4QjtBQVBILEdBQUE7QUFVQTs7Ozs7Ozs7Ozs7OztBQVdBLEVBQUEsdUNBQXVDLEdBQUcsaURBQUEsRUFBQSxFQUFBLFVBQUEsRUFBZ0Q7QUFDeEYsSUFBQSx3QkFBeUIsQ0FBQSxVQUFBLEVBQXpCLElBQXlCLENBQXpCOztBQUVBLFFBQUk7QUFDRixNQUFBLEVBQUU7QUFESixLQUFBLFNBRVU7QUFDUixNQUFBLHNCQUF1QjtBQUN4QjtBQVBILEdBQUE7O0FBVUEsTUFBSSxRQUFRLEdBQUcsU0FBWCxRQUFXLENBQUEsR0FBQSxFQUFBLE9BQUEsRUFBQSxDQUFBLEVBQTBDLFdBQTFDLEVBQThEO0FBQUEsUUFBcEIsV0FBb0I7QUFBcEIsTUFBQSxXQUFvQixHQUFOLENBQXhELENBQThEO0FBQUE7O0FBQzNFLFFBQUksQ0FBQyxHQUFMLFdBQUE7O0FBRUEsV0FBTyxDQUFDLEtBQUQsQ0FBQSxJQUFXLENBQUMsS0FBSyxHQUFHLENBQTNCLE1BQUEsRUFBb0M7QUFDbEMsTUFBQSxDQUFDLEdBQUcsR0FBRyxDQUFILE9BQUEsQ0FBQSxPQUFBLEVBQUosQ0FBSSxDQUFKO0FBQ0EsVUFBSSxDQUFDLEdBQUwsQ0FBQSxFQUFXO0FBQ1o7O0FBRUQsV0FBQSxDQUFBO0FBUkYsR0FBQTs7QUFXQSxNQUFJLHdCQUF3QixHQUFHLFNBQTNCLHdCQUEyQixDQUFBLFdBQUEsRUFBQSxHQUFBLEVBQUEsT0FBQSxFQUkzQjtBQUNGLFFBQUksT0FBTyxHQUFHLENBQUMsZUFBZSxDQUFmLFlBQUEsQ0FBQSxHQUFBLEVBQWtDLE9BQU8sSUFBSSxNQUFNLENBQWxFLE9BQWtFLENBQW5ELENBQUQsQ0FBZDtBQUVBLElBQUEsT0FBTyxDQUFQLElBQUEsT0FBa0IsTUFBTSxDQUF4QixPQUF3QixDQUF4QjtBQUVBLElBQUEsT0FBTyxDQUFQLElBQUEsQ0FBYSxnQkFBaUIsQ0FBOUIsV0FBOEIsQ0FBOUI7QUFFQSxJQUFBLE9BQU8sQ0FBUCxJQUFBO0FBRUEsV0FBTyxPQUFPLENBQVAsSUFBQSxDQUFQLE1BQU8sQ0FBUDtBQWJGLEdBQUE7O0FBZ0JBLEVBQUEsZ0JBQWdCLEdBQUksMEJBQUEsV0FBRCxFQUE4QjtBQUMvQyxRQUFJLGFBQWEsR0FBakIsRUFBQTtBQUNBLFFBQUksT0FBTyxHQUNULFdBQVcsSUFBSSxpQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBakIsTUFBQSxHQURuQyxDQUNrQyxDQURsQztBQUdBLFFBQUksT0FBTyxLQUFYLFNBQUEsRUFBMkIsT0FBQSxFQUFBOztBQUUzQixXQUFBLE9BQUEsRUFBZ0I7QUFDZCxVQUFJLE9BQU8sQ0FBWCxVQUFBLEVBQXdCO0FBQ3RCLFFBQUEsYUFBYSxDQUFiLE9BQUEsQ0FBc0IsT0FBTyxDQUE3QixVQUFBO0FBQ0Q7O0FBRUQsTUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFqQixNQUFBO0FBWjZDLEtBQUEsQ0FlL0M7OztBQUNBLFdBQU8sYUFBYSxDQUFiLEdBQUEsQ0FBa0IsVUFBQSxLQUFBLEVBQUEsS0FBQTtBQUFBLGFBQWtCLEtBQUssQ0FBQyxJQUFBLEtBQUEsR0FBTixDQUFLLENBQUwsQ0FBQSxJQUFBLENBQUEsR0FBQSxJQUFwQyxLQUFrQjtBQUFBLEtBQWxCLEVBQUEsSUFBQSxDQUFQLElBQU8sQ0FBUDtBQWhCRixHQUFBOztBQW1CQSxFQUFBLGtCQUFpQixHQUFJLDJCQUFBLElBQUQsRUFBYztBQUNoQyxRQUFJLENBQUEsYUFBQSxJQUFrQixhQUFhLENBQWIsR0FBQSxDQUF0QixJQUFzQixDQUF0QixFQUErQztBQUUvQyxJQUFBLGFBQWEsQ0FBYixHQUFBLENBQUEsSUFBQSxFQUF3QixpQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBakIsTUFBQSxHQUhWLENBR1MsQ0FBekMsRUFIZ0MsQ0FLaEM7QUFDQTtBQUNBOztBQUNBLFFBQUksR0FBRyxHQUFQLElBQUE7O0FBRUEsUUFBSSxHQUFHLENBQVAsTUFBQSxFQUFnQjtBQUNkLE1BQUEsa0JBQWtCLENBQUMsR0FBRyxDQUF0QixNQUFrQixDQUFsQjtBQUNEOztBQUVELFFBQUksR0FBRyxDQUFQLE9BQUEsRUFBaUI7QUFDZixNQUFBLEdBQUcsQ0FBSCxPQUFBLENBQUEsT0FBQSxDQUFxQixVQUFBLEdBQUQ7QUFBQSxlQUFjLGtCQUFrQixDQUFwRCxHQUFvRCxDQUFoQztBQUFBLE9BQXBCO0FBQ0Q7QUFoQkgsR0FBQTs7QUFtQkEsRUFBQSxvQkFBb0IsR0FBRyw4QkFBQSxHQUFBLEVBQUEsR0FBQSxFQUFBLE9BQUEsRUFJckIsY0FKcUIsRUFLbkI7QUFBQSxRQURGLGNBQ0U7QUFERixNQUFBLGNBQ0UsR0FMbUIsS0FLbkI7QUFBQTs7QUFDRixRQUFJLGFBQWEsS0FBakIsSUFBQSxFQUE0QjtBQUU1QixRQUFJLFdBQVcsR0FBRyxhQUFhLENBQWIsR0FBQSxDQUFsQixHQUFrQixDQUFsQjtBQUVBLFFBQUksQ0FBSixXQUFBLEVBQWtCO0FBRWxCLFFBQUksa0JBQWtCLEdBQUcsaUJBQWlCLENBQUMsaUJBQWlCLENBQWpCLE1BQUEsR0FBM0MsQ0FBMEMsQ0FBMUM7O0FBRUEsUUFBSSxrQkFBa0IsQ0FBbEIsU0FBQSxJQUFnQyxDQUFwQyxjQUFBLEVBQXFEO0FBQ25ELE1BQUEsZUFBZSxDQUFmLFNBQUEsQ0FBMEIsd0JBQXdCLENBQUEsV0FBQSxFQUFBLEdBQUEsRUFBbEQsT0FBa0QsQ0FBbEQ7QUFERixLQUFBLE1BRU87QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFJO0FBQ0YsUUFBQSxlQUFlLENBQWYsTUFBQSxDQUF1Qix3QkFBd0IsQ0FBQSxXQUFBLEVBQUEsR0FBQSxFQUEvQyxPQUErQyxDQUEvQztBQURGLE9BQUEsQ0FFRSxPQUFBLENBQUEsRUFBVTtBQUNWLFlBQUksQ0FBQyxDQUFMLEtBQUEsRUFBYTtBQUNYLGNBQUksZ0JBQWdCLEdBQUcsQ0FBQyxDQUFELEtBQUEsQ0FBQSxPQUFBLENBQXZCLDZCQUF1QixDQUF2Qjs7QUFFQSxjQUFJLGdCQUFnQixLQUFLLENBQXpCLENBQUEsRUFBNkI7QUFDM0IsZ0JBQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUYsS0FBQSxFQUFBLElBQUEsRUFBQSxDQUFBLEVBQXBCLGdCQUFvQixDQUFwQjtBQUNBLGdCQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFGLEtBQUEsRUFBQSxJQUFBLEVBQUEsQ0FBQSxFQUFsQixnQkFBa0IsQ0FBbEI7QUFDQSxZQUFBLENBQUMsQ0FBRCxLQUFBLEdBQVUsQ0FBQyxDQUFELEtBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxFQUFBLEtBQUEsSUFBMkIsQ0FBQyxDQUFELEtBQUEsQ0FBQSxNQUFBLENBQXJDLEdBQXFDLENBQXJDO0FBQ0Q7QUFDRjs7QUFFRCxjQUFBLENBQUE7QUFDRDtBQUNGO0FBbkNILEdBQUE7QUFxQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUYWcgfSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuXG5leHBvcnQgbGV0IGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbjpcbiAgfCB1bmRlZmluZWRcbiAgfCAoKGRlYnVnZ2luZ0NvbnRleHQ/OiBzdHJpbmcgfCBmYWxzZSwgZGVwcmVjYXRlPzogYm9vbGVhbikgPT4gdm9pZCk7XG5leHBvcnQgbGV0IGVuZFRyYWNraW5nVHJhbnNhY3Rpb246IHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uOlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZm46ICgpID0+IHZvaWQsIGRlYnVnZ2luZ0NvbnRleHQ/OiBzdHJpbmcgfCBmYWxzZSkgPT4gdm9pZCk7XG5leHBvcnQgbGV0IGRlcHJlY2F0ZU11dGF0aW9uc0luVHJhY2tpbmdUcmFuc2FjdGlvbjogdW5kZWZpbmVkIHwgKChmbjogKCkgPT4gdm9pZCkgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgcmVzZXRUcmFja2luZ1RyYW5zYWN0aW9uOiB1bmRlZmluZWQgfCAoKCkgPT4gc3RyaW5nKTtcbmV4cG9ydCBsZXQgc2V0VHJhY2tpbmdUcmFuc2FjdGlvbkVudjpcbiAgfCB1bmRlZmluZWRcbiAgfCAoKGVudjoge1xuICAgICAgYXNzZXJ0PyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkO1xuICAgICAgZGVwcmVjYXRlPyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkO1xuICAgICAgZGVidWdNZXNzYWdlPyhvYmo/OiB1bmtub3duLCBrZXlOYW1lPzogc3RyaW5nKTogc3RyaW5nO1xuICAgIH0pID0+IHZvaWQpO1xuXG5leHBvcnQgbGV0IGFzc2VydFRhZ05vdENvbnN1bWVkOlxuICB8IHVuZGVmaW5lZFxuICB8ICg8VD4odGFnOiBUYWcsIG9iaj86IFQsIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sLCBmb3JjZUhhcmRFcnJvcj86IGJvb2xlYW4pID0+IHZvaWQpO1xuXG5leHBvcnQgbGV0IG1hcmtUYWdBc0NvbnN1bWVkOiB1bmRlZmluZWQgfCAoKF90YWc6IFRhZykgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgbG9nVHJhY2tpbmdTdGFjazogdW5kZWZpbmVkIHwgKCh0cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKSA9PiBzdHJpbmcpO1xuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb24ge1xuICBwYXJlbnQ6IFRyYW5zYWN0aW9uIHwgbnVsbDtcbiAgZGVidWdMYWJlbD86IHN0cmluZztcbiAgZGVwcmVjYXRlOiBib29sZWFuO1xufVxuXG5pZiAoREVCVUcpIHtcbiAgbGV0IENPTlNVTUVEX1RBR1M6IFdlYWtNYXA8VGFnLCBUcmFuc2FjdGlvbj4gfCBudWxsID0gbnVsbDtcblxuICBsZXQgVFJBTlNBQ1RJT05fU1RBQ0s6IFRyYW5zYWN0aW9uW10gPSBbXTtcblxuICAvLy8vLy8vLy9cblxuICBsZXQgVFJBTlNBQ1RJT05fRU5WID0ge1xuICAgIGFzc2VydChtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9LFxuXG4gICAgZGVwcmVjYXRlKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH0sXG5cbiAgICBkZWJ1Z01lc3NhZ2Uob2JqPzogdW5rbm93biwga2V5TmFtZT86IHN0cmluZykge1xuICAgICAgbGV0IG9iak5hbWU7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9iak5hbWUgPSBvYmoubmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSAob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnKHVua25vd24gY2xhc3MpJztcblxuICAgICAgICBvYmpOYW1lID0gYChhbiBpbnN0YW5jZSBvZiAke2NsYXNzTmFtZX0pYDtcbiAgICAgIH0gZWxzZSBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqTmFtZSA9ICcoYW4gdW5rbm93biB0YWcpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iak5hbWUgPSBTdHJpbmcob2JqKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRpcnR5U3RyaW5nID0ga2V5TmFtZSA/IGBcXGAke2tleU5hbWV9XFxgIG9uIFxcYCR7b2JqTmFtZX1cXGBgIDogYFxcYCR7b2JqTmFtZX1cXGBgO1xuXG4gICAgICByZXR1cm4gYFlvdSBhdHRlbXB0ZWQgdG8gdXBkYXRlICR7ZGlydHlTdHJpbmd9LCBidXQgaXQgaGFkIGFscmVhZHkgYmVlbiB1c2VkIHByZXZpb3VzbHkgaW4gdGhlIHNhbWUgY29tcHV0YXRpb24uICBBdHRlbXB0aW5nIHRvIHVwZGF0ZSBhIHZhbHVlIGFmdGVyIHVzaW5nIGl0IGluIGEgY29tcHV0YXRpb24gY2FuIGNhdXNlIGxvZ2ljYWwgZXJyb3JzLCBpbmZpbml0ZSByZXZhbGlkYXRpb24gYnVncywgYW5kIHBlcmZvcm1hbmNlIGlzc3VlcywgYW5kIGlzIG5vdCBzdXBwb3J0ZWQuYDtcbiAgICB9LFxuICB9O1xuXG4gIHNldFRyYWNraW5nVHJhbnNhY3Rpb25FbnYgPSAoZW52KSA9PiBPYmplY3QuYXNzaWduKFRSQU5TQUNUSU9OX0VOViwgZW52KTtcblxuICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24gPSAoX2RlYnVnTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSwgZGVwcmVjYXRlID0gZmFsc2UpID0+IHtcbiAgICBDT05TVU1FRF9UQUdTID0gQ09OU1VNRURfVEFHUyB8fCBuZXcgV2Vha01hcCgpO1xuXG4gICAgbGV0IGRlYnVnTGFiZWwgPSBfZGVidWdMYWJlbCB8fCB1bmRlZmluZWQ7XG5cbiAgICBsZXQgcGFyZW50ID0gVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0gfHwgbnVsbDtcblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLLnB1c2goe1xuICAgICAgcGFyZW50LFxuICAgICAgZGVidWdMYWJlbCxcbiAgICAgIGRlcHJlY2F0ZSxcbiAgICB9KTtcbiAgfTtcblxuICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgIGlmIChUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIGNsb3NlIGEgdHJhY2tpbmcgdHJhbnNhY3Rpb24sIGJ1dCBvbmUgd2FzIG5vdCBvcGVuJyk7XG4gICAgfVxuXG4gICAgVFJBTlNBQ1RJT05fU1RBQ0sucG9wKCk7XG5cbiAgICBpZiAoVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoID09PSAwKSB7XG4gICAgICBDT05TVU1FRF9UQUdTID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmVzZXRUcmFja2luZ1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgIGxldCBzdGFjayA9ICcnO1xuXG4gICAgaWYgKFRSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrID0gbG9nVHJhY2tpbmdTdGFjayEoVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0pO1xuICAgIH1cblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLID0gW107XG4gICAgQ09OU1VNRURfVEFHUyA9IG51bGw7XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBnbG9iYWwgYXV0b3RyYWNraW5nIHRyYW5zYWN0aW9uLiBUaGlzIHdpbGwgcHJldmVudCBhbnkgYmFja2Zsb3dcbiAgICogaW4gYW55IGB0cmFja2AgY2FsbHMgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiwgZXZlbiBpZiB0aGV5IGFyZSBub3RcbiAgICogZXh0ZXJuYWxseSBjb25zdW1lZC5cbiAgICpcbiAgICogYHJ1bkluQXV0b3RyYWNraW5nVHJhbnNhY3Rpb25gIGNhbiBiZSBjYWxsZWQgd2l0aGluIGl0c2VsZiwgYW5kIGl0IHdpbGwgYWRkXG4gICAqIG9udG8gdGhlIGV4aXN0aW5nIHRyYW5zYWN0aW9uIGlmIG9uZSBleGlzdHMuXG4gICAqXG4gICAqIFRPRE86IE9ubHkgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGB0cmFja2AgaXMgY29uc3VtZWQuXG4gICAqL1xuICBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24gPSAoZm46ICgpID0+IHZvaWQsIGRlYnVnTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSkgPT4ge1xuICAgIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiEoZGVidWdMYWJlbCk7XG5cbiAgICB0cnkge1xuICAgICAgZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbiEoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIGRlcHJlY2F0aW5nIHdpdGhpbiBhbiBhdXRvdHJhY2tpbmcgdHJhbnNhY3Rpb24sIGlmIG9uZSBleGlzdHMuXG4gICAqIElmIGBydW5JbkF1dG90cmFja2luZ1RyYW5zYWN0aW9uYCBpcyBjYWxsZWQgd2l0aGluIHRoZSBjYWxsYmFjayBvZiB0aGlzXG4gICAqIG1ldGhvZCwgaXQgc3dpdGNoZXMgYmFjayB0byB0aHJvd2luZyBhbiBlcnJvciwgYWxsb3dpbmcgemVicmEtc3RyaXBpbmcgb2ZcbiAgICogdGhlIHR5cGVzIG9mIGVycm9ycyB0aGF0IGFyZSB0aHJvd24uXG4gICAqXG4gICAqIERvZXMgbm90IHN0YXJ0IGFuIGF1dG90cmFja2luZyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogTk9URTogRm9yIEVtYmVyIHVzYWdlIG9ubHksIGluIGdlbmVyYWwgeW91IHNob3VsZCBhc3NlcnQgdGhhdCB0aGVzZVxuICAgKiBpbnZhcmlhbnRzIGFyZSB0cnVlLlxuICAgKi9cbiAgZGVwcmVjYXRlTXV0YXRpb25zSW5UcmFja2luZ1RyYW5zYWN0aW9uID0gKGZuOiAoKSA9PiB2b2lkLCBkZWJ1Z0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpID0+IHtcbiAgICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24hKGRlYnVnTGFiZWwsIHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZFRyYWNraW5nVHJhbnNhY3Rpb24hKCk7XG4gICAgfVxuICB9O1xuXG4gIGxldCBudGhJbmRleCA9IChzdHI6IHN0cmluZywgcGF0dGVybjogc3RyaW5nLCBuOiBudW1iZXIsIHN0YXJ0aW5nUG9zID0gLTEpID0+IHtcbiAgICBsZXQgaSA9IHN0YXJ0aW5nUG9zO1xuXG4gICAgd2hpbGUgKG4tLSA+IDAgJiYgaSsrIDwgc3RyLmxlbmd0aCkge1xuICAgICAgaSA9IHN0ci5pbmRleE9mKHBhdHRlcm4sIGkpO1xuICAgICAgaWYgKGkgPCAwKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBsZXQgbWFrZVRyYWNraW5nRXJyb3JNZXNzYWdlID0gPFQ+KFxuICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbixcbiAgICBvYmo/OiBULFxuICAgIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sXG4gICkgPT4ge1xuICAgIGxldCBtZXNzYWdlID0gW1RSQU5TQUNUSU9OX0VOVi5kZWJ1Z01lc3NhZ2Uob2JqLCBrZXlOYW1lICYmIFN0cmluZyhrZXlOYW1lKSldO1xuXG4gICAgbWVzc2FnZS5wdXNoKGBcXGAke1N0cmluZyhrZXlOYW1lKX1cXGAgd2FzIGZpcnN0IHVzZWQ6YCk7XG5cbiAgICBtZXNzYWdlLnB1c2gobG9nVHJhY2tpbmdTdGFjayEodHJhbnNhY3Rpb24pKTtcblxuICAgIG1lc3NhZ2UucHVzaChgU3RhY2sgdHJhY2UgZm9yIHRoZSB1cGRhdGU6YCk7XG5cbiAgICByZXR1cm4gbWVzc2FnZS5qb2luKCdcXG5cXG4nKTtcbiAgfTtcblxuICBsb2dUcmFja2luZ1N0YWNrID0gKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IHtcbiAgICBsZXQgdHJhY2tpbmdTdGFjayA9IFtdO1xuICAgIGxldCBjdXJyZW50OiBUcmFuc2FjdGlvbiB8IG51bGwgfCB1bmRlZmluZWQgPVxuICAgICAgdHJhbnNhY3Rpb24gfHwgVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG5cbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuZGVidWdMYWJlbCkge1xuICAgICAgICB0cmFja2luZ1N0YWNrLnVuc2hpZnQoY3VycmVudC5kZWJ1Z0xhYmVsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCBoZXJlIG9uY2Ugd2UgY2FuIGRyb3Agc3VwcG9ydCBmb3IgSUUxMVxuICAgIHJldHVybiB0cmFja2luZ1N0YWNrLm1hcCgobGFiZWwsIGluZGV4KSA9PiBBcnJheSgyICogaW5kZXggKyAxKS5qb2luKCcgJykgKyBsYWJlbCkuam9pbignXFxuJyk7XG4gIH07XG5cbiAgbWFya1RhZ0FzQ29uc3VtZWQgPSAoX3RhZzogVGFnKSA9PiB7XG4gICAgaWYgKCFDT05TVU1FRF9UQUdTIHx8IENPTlNVTUVEX1RBR1MuaGFzKF90YWcpKSByZXR1cm47XG5cbiAgICBDT05TVU1FRF9UQUdTLnNldChfdGFnLCBUUkFOU0FDVElPTl9TVEFDS1tUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggLSAxXSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIG1hcmsgdGhlIHRhZyBhbmQgYWxsIG9mIGl0cyBzdWJ0YWdzIGFzIGNvbnN1bWVkLCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gY2FzdCBpdCBhbmQgYWNjZXNzIGl0cyBpbnRlcm5hbHMuIEluIHRoZSBmdXR1cmUgdGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LFxuICAgIC8vIHRoaXMgaXMgb25seSBmb3IgY29tcHV0ZWQgcHJvcGVydGllcy5cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBhbnk7XG5cbiAgICBpZiAodGFnLnN1YnRhZykge1xuICAgICAgbWFya1RhZ0FzQ29uc3VtZWQhKHRhZy5zdWJ0YWcpO1xuICAgIH1cblxuICAgIGlmICh0YWcuc3VidGFncykge1xuICAgICAgdGFnLnN1YnRhZ3MuZm9yRWFjaCgodGFnOiBUYWcpID0+IG1hcmtUYWdBc0NvbnN1bWVkISh0YWcpKTtcbiAgICB9XG4gIH07XG5cbiAgYXNzZXJ0VGFnTm90Q29uc3VtZWQgPSA8VD4oXG4gICAgdGFnOiBUYWcsXG4gICAgb2JqPzogVCxcbiAgICBrZXlOYW1lPzoga2V5b2YgVCB8IHN0cmluZyB8IHN5bWJvbCxcbiAgICBmb3JjZUhhcmRFcnJvcjogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IGZhbHNlXG4gICkgPT4ge1xuICAgIGlmIChDT05TVU1FRF9UQUdTID09PSBudWxsKSByZXR1cm47XG5cbiAgICBsZXQgdHJhbnNhY3Rpb24gPSBDT05TVU1FRF9UQUdTLmdldCh0YWcpO1xuXG4gICAgaWYgKCF0cmFuc2FjdGlvbikgcmV0dXJuO1xuXG4gICAgbGV0IGN1cnJlbnRUcmFuc2FjdGlvbiA9IFRSQU5TQUNUSU9OX1NUQUNLW1RSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGN1cnJlbnRUcmFuc2FjdGlvbi5kZXByZWNhdGUgJiYgIWZvcmNlSGFyZEVycm9yKSB7XG4gICAgICBUUkFOU0FDVElPTl9FTlYuZGVwcmVjYXRlKG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSh0cmFuc2FjdGlvbiwgb2JqLCBrZXlOYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaGFjayBtYWtlcyB0aGUgYXNzZXJ0aW9uIG1lc3NhZ2UgbmljZXIsIHdlIGNhbiBjdXQgb2ZmIHRoZSBmaXJzdFxuICAgICAgLy8gZmV3IGxpbmVzIG9mIHRoZSBzdGFjayB0cmFjZSBhbmQgbGV0IHVzZXJzIGtub3cgd2hlcmUgdGhlIGFjdHVhbCBlcnJvclxuICAgICAgLy8gb2NjdXJyZWQuXG4gICAgICB0cnkge1xuICAgICAgICBUUkFOU0FDVElPTl9FTlYuYXNzZXJ0KG1ha2VUcmFja2luZ0Vycm9yTWVzc2FnZSh0cmFuc2FjdGlvbiwgb2JqLCBrZXlOYW1lKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnN0YWNrKSB7XG4gICAgICAgICAgbGV0IHVwZGF0ZVN0YWNrQmVnaW4gPSBlLnN0YWNrLmluZGV4T2YoJ1N0YWNrIHRyYWNlIGZvciB0aGUgdXBkYXRlOicpO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVN0YWNrQmVnaW4gIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBudGhJbmRleChlLnN0YWNrLCAnXFxuJywgMSwgdXBkYXRlU3RhY2tCZWdpbik7XG4gICAgICAgICAgICBsZXQgZW5kID0gbnRoSW5kZXgoZS5zdGFjaywgJ1xcbicsIDQsIHVwZGF0ZVN0YWNrQmVnaW4pO1xuICAgICAgICAgICAgZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyKDAsIHN0YXJ0KSArIGUuc3RhY2suc3Vic3RyKGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9