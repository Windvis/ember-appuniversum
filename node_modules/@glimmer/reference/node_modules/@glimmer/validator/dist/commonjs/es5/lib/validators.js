"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bump = bump;
exports.valueForTag = valueForTag;
exports.validateTag = validateTag;
exports.createTag = createTag;
exports.createUpdatableTag = createUpdatableTag;
exports.isConstTag = isConstTag;
exports.combine = exports.CURRENT_TAG = exports.CurrentTag = exports.VOLATILE_TAG = exports.VolatileTag = exports.CONSTANT_TAG = exports.UPDATE_TAG = exports.DIRTY_TAG = exports.ALLOW_CYCLES = exports.COMPUTE = exports.VOLATILE = exports.INITIAL = exports.CONSTANT = void 0;

var _env = require("@glimmer/env");

var _globalContext = require("@glimmer/global-context");

var _utils = require("./utils");

var _debug = require("./debug");

var CONSTANT = 0;
exports.CONSTANT = CONSTANT;
var INITIAL = 1;
exports.INITIAL = INITIAL;
var VOLATILE = NaN;
exports.VOLATILE = VOLATILE;
var $REVISION = INITIAL;

function bump() {
  $REVISION++;
} //////////


var COMPUTE = (0, _utils.symbol)('TAG_COMPUTE'); //////////

/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */

exports.COMPUTE = COMPUTE;

function valueForTag(tag) {
  return tag[COMPUTE]();
}
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */


function validateTag(tag, snapshot) {
  return snapshot >= tag[COMPUTE]();
}

var TYPE = (0, _utils.symbol)('TAG_TYPE'); // this is basically a const
// eslint-disable-next-line @typescript-eslint/naming-convention

var ALLOW_CYCLES;
exports.ALLOW_CYCLES = ALLOW_CYCLES;

if (_env.DEBUG) {
  exports.ALLOW_CYCLES = ALLOW_CYCLES = new WeakMap();
}

function allowsCycles(tag) {
  if (ALLOW_CYCLES === undefined) {
    return true;
  } else {
    return ALLOW_CYCLES.has(tag);
  }
}

var MonomorphicTagImpl = /*#__PURE__*/function () {
  function MonomorphicTagImpl(type) {
    this.revision = INITIAL;
    this.lastChecked = INITIAL;
    this.lastValue = INITIAL;
    this.isUpdating = false;
    this.subtag = null;
    this.subtagBufferCache = null;
    this[TYPE] = type;
  }

  MonomorphicTagImpl.combine = function combine(tags) {
    switch (tags.length) {
      case 0:
        return CONSTANT_TAG;

      case 1:
        return tags[0];

      default:
        var tag = new MonomorphicTagImpl(2
        /* Combinator */
        );
        tag.subtag = tags;
        return tag;
    }
  };

  var _proto = MonomorphicTagImpl.prototype;

  _proto[COMPUTE] = function () {
    var lastChecked = this.lastChecked;

    if (this.isUpdating === true) {
      if (_env.DEBUG && !allowsCycles(this)) {
        throw new Error('Cycles in tags are not allowed');
      }

      this.lastChecked = ++$REVISION;
    } else if (lastChecked !== $REVISION) {
      this.isUpdating = true;
      this.lastChecked = $REVISION;

      try {
        var subtag = this.subtag,
            revision = this.revision;

        if (subtag !== null) {
          if (Array.isArray(subtag)) {
            for (var i = 0; i < subtag.length; i++) {
              var value = subtag[i][COMPUTE]();
              revision = Math.max(value, revision);
            }
          } else {
            var subtagValue = subtag[COMPUTE]();

            if (subtagValue === this.subtagBufferCache) {
              revision = Math.max(revision, this.lastValue);
            } else {
              // Clear the temporary buffer cache
              this.subtagBufferCache = null;
              revision = Math.max(revision, subtagValue);
            }
          }
        }

        this.lastValue = revision;
      } finally {
        this.isUpdating = false;
      }
    }

    return this.lastValue;
  };

  MonomorphicTagImpl.updateTag = function updateTag(_tag, _subtag) {
    if (_env.DEBUG && _tag[TYPE] !== 1
    /* Updatable */
    ) {
        throw new Error('Attempted to update a tag that was not updatable');
      } // TODO: TS 3.7 should allow us to do this via assertion


    var tag = _tag;
    var subtag = _subtag;

    if (subtag === CONSTANT_TAG) {
      tag.subtag = null;
    } else {
      // There are two different possibilities when updating a subtag:
      //
      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();
      // 2. subtag[COMPUTE]() > tag[COMPUTE]();
      //
      // The first possibility is completely fine within our caching model, but
      // the second possibility presents a problem. If the parent tag has
      // already been read, then it's value is cached and will not update to
      // reflect the subtag's greater value. Next time the cache is busted, the
      // subtag's value _will_ be read, and it's value will be _greater_ than
      // the saved snapshot of the parent, causing the resulting calculation to
      // be rerun erroneously.
      //
      // In order to prevent this, when we first update to a new subtag we store
      // its computed value, and then check against that computed value on
      // subsequent updates. If its value hasn't changed, then we return the
      // parent's previous value. Once the subtag changes for the first time,
      // we clear the cache and everything is finally in sync with the parent.
      tag.subtagBufferCache = subtag[COMPUTE]();
      tag.subtag = subtag;
    }
  };

  MonomorphicTagImpl.dirtyTag = function dirtyTag(tag) {
    if (_env.DEBUG && !(tag[TYPE] === 1
    /* Updatable */
    || tag[TYPE] === 0
    /* Dirtyable */
    )) {
      throw new Error('Attempted to dirty a tag that was not dirtyable');
    }

    if (_env.DEBUG) {
      // Usually by this point, we've already asserted with better error information,
      // but this is our last line of defense.
      (0, _utils.unwrap)(_debug.assertTagNotConsumed)(tag);
    }

    tag.revision = ++$REVISION;
    (0, _globalContext.scheduleRevalidate)();
  };

  return MonomorphicTagImpl;
}();

var DIRTY_TAG = MonomorphicTagImpl.dirtyTag;
exports.DIRTY_TAG = DIRTY_TAG;
var UPDATE_TAG = MonomorphicTagImpl.updateTag; //////////

exports.UPDATE_TAG = UPDATE_TAG;

function createTag() {
  return new MonomorphicTagImpl(0
  /* Dirtyable */
  );
}

function createUpdatableTag() {
  return new MonomorphicTagImpl(1
  /* Updatable */
  );
} //////////


var CONSTANT_TAG = new MonomorphicTagImpl(3
/* Constant */
);
exports.CONSTANT_TAG = CONSTANT_TAG;

function isConstTag(tag) {
  return tag === CONSTANT_TAG;
} //////////


var VolatileTag = /*#__PURE__*/function () {
  function VolatileTag() {}

  var _proto2 = VolatileTag.prototype;

  _proto2[COMPUTE] = function () {
    return VOLATILE;
  };

  return VolatileTag;
}();

exports.VolatileTag = VolatileTag;
var VOLATILE_TAG = new VolatileTag(); //////////

exports.VOLATILE_TAG = VOLATILE_TAG;

var CurrentTag = /*#__PURE__*/function () {
  function CurrentTag() {}

  var _proto3 = CurrentTag.prototype;

  _proto3[COMPUTE] = function () {
    return $REVISION;
  };

  return CurrentTag;
}();

exports.CurrentTag = CurrentTag;
var CURRENT_TAG = new CurrentTag(); //////////

exports.CURRENT_TAG = CURRENT_TAG;
var combine = MonomorphicTagImpl.combine; // Warm

exports.combine = combine;
var tag1 = createUpdatableTag();
var tag2 = createUpdatableTag();
var tag3 = createUpdatableTag();
valueForTag(tag1);
DIRTY_TAG(tag1);
valueForTag(tag1);
UPDATE_TAG(tag1, combine([tag2, tag3]));
valueForTag(tag1);
DIRTY_TAG(tag2);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
UPDATE_TAG(tag1, tag3);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBTU8sSUFBTSxRQUFRLEdBQWQsQ0FBQTs7QUFDQSxJQUFNLE9BQU8sR0FBYixDQUFBOztBQUNBLElBQU0sUUFBUSxHQUFkLEdBQUE7O0FBRVAsSUFBSSxTQUFTLEdBQWIsT0FBQTs7QUFFTSxTQUFBLElBQUEsR0FBYztBQUNsQixFQUFBLFNBQVM7RUFHWDs7O0FBRU8sSUFBTSxPQUFPLEdBQWtCLG1CQUEvQixhQUErQixDQUEvQixDLENBUVA7O0FBRUE7Ozs7Ozs7Ozs7O0FBUU0sU0FBQSxXQUFBLENBQUEsR0FBQSxFQUE4QjtBQUNsQyxTQUFPLEdBQUcsQ0FBVixPQUFVLENBQUgsRUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7OztBQVVNLFNBQUEsV0FBQSxDQUFBLEdBQUEsRUFBQSxRQUFBLEVBQWtEO0FBQ3RELFNBQU8sUUFBUSxJQUFJLEdBQUcsQ0FBdEIsT0FBc0IsQ0FBSCxFQUFuQjtBQUNEOztBQWlCRCxJQUFNLElBQUksR0FBa0IsbUJBQTVCLFVBQTRCLENBQTVCLEMsQ0FFQTtBQUNBOztBQUNPLElBQUEsWUFBQTs7O0FBRVAsSUFBQSxVQUFBLEVBQVc7QUFDVCx5QkFBQSxZQUFZLEdBQUcsSUFBZixPQUFlLEVBQWY7QUFDRDs7QUFFRCxTQUFBLFlBQUEsQ0FBQSxHQUFBLEVBQThCO0FBQzVCLE1BQUksWUFBWSxLQUFoQixTQUFBLEVBQWdDO0FBQzlCLFdBQUEsSUFBQTtBQURGLEdBQUEsTUFFTztBQUNMLFdBQU8sWUFBWSxDQUFaLEdBQUEsQ0FBUCxHQUFPLENBQVA7QUFDRDtBQUNGOztJQVdELGtCO0FBdUJFLFdBQUEsa0JBQUEsQ0FBQSxJQUFBLEVBQW1CO0FBVlgsU0FBQSxRQUFBLEdBQUEsT0FBQTtBQUNBLFNBQUEsV0FBQSxH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WCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHNjaGVkdWxlUmV2YWxpZGF0ZSB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcbmltcG9ydCB7IHN5bWJvbCwgdW53cmFwIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBhc3NlcnRUYWdOb3RDb25zdW1lZCB9IGZyb20gJy4vZGVidWcnO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIFJldmlzaW9uID0gbnVtYmVyO1xuXG5leHBvcnQgY29uc3QgQ09OU1RBTlQ6IFJldmlzaW9uID0gMDtcbmV4cG9ydCBjb25zdCBJTklUSUFMOiBSZXZpc2lvbiA9IDE7XG5leHBvcnQgY29uc3QgVk9MQVRJTEU6IFJldmlzaW9uID0gTmFOO1xuXG5sZXQgJFJFVklTSU9OID0gSU5JVElBTDtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXAoKTogdm9pZCB7XG4gICRSRVZJU0lPTisrO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT01QVVRFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUQUdfQ09NUFVURScpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eVRhZzxUPiB7XG4gIFtDT01QVVRFXSgpOiBUO1xufVxuXG5leHBvcnQgdHlwZSBUYWcgPSBFbnRpdHlUYWc8UmV2aXNpb24+O1xuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogYHZhbHVlYCByZWNlaXZlcyBhIHRhZyBhbmQgcmV0dXJucyBhbiBvcGFxdWUgUmV2aXNpb24gYmFzZWQgb24gdGhhdCB0YWcuIFRoaXNcbiAqIHNuYXBzaG90IGNhbiB0aGVuIGxhdGVyIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIHdpdGggdGhlIHNhbWUgdGFnIHRvXG4gKiBkZXRlcm1pbmUgaWYgdGhlIHRhZyBoYXMgY2hhbmdlZCBhdCBhbGwgc2luY2UgdGhlIHRpbWUgdGhhdCBgdmFsdWVgIHdhc1xuICogY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlRm9yVGFnKHRhZzogVGFnKTogUmV2aXNpb24ge1xuICByZXR1cm4gdGFnW0NPTVBVVEVdKCk7XG59XG5cbi8qKlxuICogYHZhbGlkYXRlYCByZWNlaXZlcyBhIHRhZyBhbmQgYSBzbmFwc2hvdCBmcm9tIGEgcHJldmlvdXMgY2FsbCB0byBgdmFsdWVgIHdpdGhcbiAqIHRoZSBzYW1lIHRhZywgYW5kIGRldGVybWluZXMgaWYgdGhlIHRhZyBpcyBzdGlsbCB2YWxpZCBjb21wYXJlZCB0byB0aGVcbiAqIHNuYXBzaG90LiBJZiB0aGUgdGFnJ3Mgc3RhdGUgaGFzIGNoYW5nZWQgYXQgYWxsIHNpbmNlIHRoZW4sIGB2YWxpZGF0ZWAgd2lsbFxuICogcmV0dXJuIGZhbHNlLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gdHJ1ZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhXG4gKiBjYWxjdWxhdGlvbiByZWxhdGVkIHRvIHRoZSB0YWdzIHNob3VsZCBiZSByZXJ1bi5cbiAqXG4gKiBAcGFyYW0gdGFnXG4gKiBAcGFyYW0gc25hcHNob3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVGFnKHRhZzogVGFnLCBzbmFwc2hvdDogUmV2aXNpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHNuYXBzaG90ID49IHRhZ1tDT01QVVRFXSgpO1xufVxuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogVGhpcyBlbnVtIHJlcHJlc2VudHMgYWxsIG9mIHRoZSBwb3NzaWJsZSB0YWcgdHlwZXMgZm9yIHRoZSBtb25vbW9ycGhpYyB0YWcgY2xhc3MuXG4gKiBPdGhlciBjdXN0b20gdGFnIGNsYXNzZXMgY2FuIGV4aXN0LCBzdWNoIGFzIEN1cnJlbnRUYWcgYW5kIFZvbGF0aWxlVGFnLCBidXQgZm9yXG4gKiBwZXJmb3JtYW5jZSByZWFzb25zLCBhbnkgdHlwZSBvZiB0YWcgdGhhdCBpcyBtZWFudCB0byBiZSB1c2VkIGZyZXF1ZW50bHkgc2hvdWxkXG4gKiBiZSBhZGRlZCB0byB0aGUgbW9ub21vcnBoaWMgdGFnLlxuICovXG5jb25zdCBlbnVtIE1vbm9tb3JwaGljVGFnVHlwZXMge1xuICBEaXJ0eWFibGUsXG4gIFVwZGF0YWJsZSxcbiAgQ29tYmluYXRvcixcbiAgQ29uc3RhbnQsXG59XG5cbmNvbnN0IFRZUEU6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1RBR19UWVBFJyk7XG5cbi8vIHRoaXMgaXMgYmFzaWNhbGx5IGEgY29uc3Rcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBsZXQgQUxMT1dfQ1lDTEVTOiBXZWFrTWFwPFRhZywgYm9vbGVhbj4gfCB1bmRlZmluZWQ7XG5cbmlmIChERUJVRykge1xuICBBTExPV19DWUNMRVMgPSBuZXcgV2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBhbGxvd3NDeWNsZXModGFnOiBUYWcpOiBib29sZWFuIHtcbiAgaWYgKEFMTE9XX0NZQ0xFUyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFMTE9XX0NZQ0xFUy5oYXModGFnKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgTW9ub21vcnBoaWNUYWdCYXNlPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzPiBleHRlbmRzIFRhZyB7XG4gIFtUWVBFXTogVDtcbn1cblxuZXhwb3J0IHR5cGUgRGlydHlhYmxlVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlPjtcbmV4cG9ydCB0eXBlIFVwZGF0YWJsZVRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZT47XG5leHBvcnQgdHlwZSBDb21iaW5hdG9yVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuQ29tYmluYXRvcj47XG5leHBvcnQgdHlwZSBDb25zdGFudFRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbnN0YW50PjtcblxuY2xhc3MgTW9ub21vcnBoaWNUYWdJbXBsPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzID0gTW9ub21vcnBoaWNUYWdUeXBlcz4ge1xuICBzdGF0aWMgY29tYmluZSh0YWdzOiBUYWdbXSk6IFRhZyB7XG4gICAgc3dpdGNoICh0YWdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gQ09OU1RBTlRfVEFHO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGFnc1swXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0YWc6IE1vbm9tb3JwaGljVGFnSW1wbCA9IG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5Db21iaW5hdG9yKTtcbiAgICAgICAgdGFnLnN1YnRhZyA9IHRhZ3M7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgcmV2aXNpb24gPSBJTklUSUFMO1xuICBwcml2YXRlIGxhc3RDaGVja2VkID0gSU5JVElBTDtcbiAgcHJpdmF0ZSBsYXN0VmFsdWUgPSBJTklUSUFMO1xuXG4gIHByaXZhdGUgaXNVcGRhdGluZyA9IGZhbHNlO1xuICBwcml2YXRlIHN1YnRhZzogVGFnIHwgVGFnW10gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdWJ0YWdCdWZmZXJDYWNoZTogUmV2aXNpb24gfCBudWxsID0gbnVsbDtcblxuICBbVFlQRV06IFQ7XG5cbiAgY29uc3RydWN0b3IodHlwZTogVCkge1xuICAgIHRoaXNbVFlQRV0gPSB0eXBlO1xuICB9XG5cbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICBsZXQgeyBsYXN0Q2hlY2tlZCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzVXBkYXRpbmcgPT09IHRydWUpIHtcbiAgICAgIGlmIChERUJVRyAmJiAhYWxsb3dzQ3ljbGVzKHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGVzIGluIHRhZ3MgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdENoZWNrZWQgPSArKyRSRVZJU0lPTjtcbiAgICB9IGVsc2UgaWYgKGxhc3RDaGVja2VkICE9PSAkUkVWSVNJT04pIHtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RDaGVja2VkID0gJFJFVklTSU9OO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyBzdWJ0YWcsIHJldmlzaW9uIH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdWJ0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJ0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBzdWJ0YWdbaV1bQ09NUFVURV0oKTtcbiAgICAgICAgICAgICAgcmV2aXNpb24gPSBNYXRoLm1heCh2YWx1ZSwgcmV2aXNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3VidGFnVmFsdWUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcblxuICAgICAgICAgICAgaWYgKHN1YnRhZ1ZhbHVlID09PSB0aGlzLnN1YnRhZ0J1ZmZlckNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldmlzaW9uID0gTWF0aC5tYXgocmV2aXNpb24sIHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0ZW1wb3JhcnkgYnVmZmVyIGNhY2hlXG4gICAgICAgICAgICAgIHRoaXMuc3VidGFnQnVmZmVyQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICByZXZpc2lvbiA9IE1hdGgubWF4KHJldmlzaW9uLCBzdWJ0YWdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSByZXZpc2lvbjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhc3RWYWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVUYWcoX3RhZzogVXBkYXRhYmxlVGFnLCBfc3VidGFnOiBUYWcpIHtcbiAgICBpZiAoREVCVUcgJiYgX3RhZ1tUWVBFXSAhPT0gTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVwZGF0ZSBhIHRhZyB0aGF0IHdhcyBub3QgdXBkYXRhYmxlJyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVFMgMy43IHNob3VsZCBhbGxvdyB1cyB0byBkbyB0aGlzIHZpYSBhc3NlcnRpb25cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBNb25vbW9ycGhpY1RhZ0ltcGw7XG4gICAgbGV0IHN1YnRhZyA9IF9zdWJ0YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsO1xuXG4gICAgaWYgKHN1YnRhZyA9PT0gQ09OU1RBTlRfVEFHKSB7XG4gICAgICB0YWcuc3VidGFnID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgcG9zc2liaWxpdGllcyB3aGVuIHVwZGF0aW5nIGEgc3VidGFnOlxuICAgICAgLy9cbiAgICAgIC8vIDEuIHN1YnRhZ1tDT01QVVRFXSgpIDw9IHRhZ1tDT01QVVRFXSgpO1xuICAgICAgLy8gMi4gc3VidGFnW0NPTVBVVEVdKCkgPiB0YWdbQ09NUFVURV0oKTtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgZmlyc3QgcG9zc2liaWxpdHkgaXMgY29tcGxldGVseSBmaW5lIHdpdGhpbiBvdXIgY2FjaGluZyBtb2RlbCwgYnV0XG4gICAgICAvLyB0aGUgc2Vjb25kIHBvc3NpYmlsaXR5IHByZXNlbnRzIGEgcHJvYmxlbS4gSWYgdGhlIHBhcmVudCB0YWcgaGFzXG4gICAgICAvLyBhbHJlYWR5IGJlZW4gcmVhZCwgdGhlbiBpdCdzIHZhbHVlIGlzIGNhY2hlZCBhbmQgd2lsbCBub3QgdXBkYXRlIHRvXG4gICAgICAvLyByZWZsZWN0IHRoZSBzdWJ0YWcncyBncmVhdGVyIHZhbHVlLiBOZXh0IHRpbWUgdGhlIGNhY2hlIGlzIGJ1c3RlZCwgdGhlXG4gICAgICAvLyBzdWJ0YWcncyB2YWx1ZSBfd2lsbF8gYmUgcmVhZCwgYW5kIGl0J3MgdmFsdWUgd2lsbCBiZSBfZ3JlYXRlcl8gdGhhblxuICAgICAgLy8gdGhlIHNhdmVkIHNuYXBzaG90IG9mIHRoZSBwYXJlbnQsIGNhdXNpbmcgdGhlIHJlc3VsdGluZyBjYWxjdWxhdGlvbiB0b1xuICAgICAgLy8gYmUgcmVydW4gZXJyb25lb3VzbHkuXG4gICAgICAvL1xuICAgICAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCB0aGlzLCB3aGVuIHdlIGZpcnN0IHVwZGF0ZSB0byBhIG5ldyBzdWJ0YWcgd2Ugc3RvcmVcbiAgICAgIC8vIGl0cyBjb21wdXRlZCB2YWx1ZSwgYW5kIHRoZW4gY2hlY2sgYWdhaW5zdCB0aGF0IGNvbXB1dGVkIHZhbHVlIG9uXG4gICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuIElmIGl0cyB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgdGhlbiB3ZSByZXR1cm4gdGhlXG4gICAgICAvLyBwYXJlbnQncyBwcmV2aW91cyB2YWx1ZS4gT25jZSB0aGUgc3VidGFnIGNoYW5nZXMgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIGFuZCBldmVyeXRoaW5nIGlzIGZpbmFsbHkgaW4gc3luYyB3aXRoIHRoZSBwYXJlbnQuXG4gICAgICB0YWcuc3VidGFnQnVmZmVyQ2FjaGUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcbiAgICAgIHRhZy5zdWJ0YWcgPSBzdWJ0YWc7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRpcnR5VGFnKHRhZzogRGlydHlhYmxlVGFnIHwgVXBkYXRhYmxlVGFnKSB7XG4gICAgaWYgKFxuICAgICAgREVCVUcgJiZcbiAgICAgICEodGFnW1RZUEVdID09PSBNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZSB8fCB0YWdbVFlQRV0gPT09IE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gZGlydHkgYSB0YWcgdGhhdCB3YXMgbm90IGRpcnR5YWJsZScpO1xuICAgIH1cblxuICAgIGlmIChERUJVRykge1xuICAgICAgLy8gVXN1YWxseSBieSB0aGlzIHBvaW50LCB3ZSd2ZSBhbHJlYWR5IGFzc2VydGVkIHdpdGggYmV0dGVyIGVycm9yIGluZm9ybWF0aW9uLFxuICAgICAgLy8gYnV0IHRoaXMgaXMgb3VyIGxhc3QgbGluZSBvZiBkZWZlbnNlLlxuICAgICAgdW53cmFwKGFzc2VydFRhZ05vdENvbnN1bWVkKSh0YWcpO1xuICAgIH1cblxuICAgICh0YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsKS5yZXZpc2lvbiA9ICsrJFJFVklTSU9OO1xuXG4gICAgc2NoZWR1bGVSZXZhbGlkYXRlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERJUlRZX1RBRyA9IE1vbm9tb3JwaGljVGFnSW1wbC5kaXJ0eVRhZztcbmV4cG9ydCBjb25zdCBVUERBVEVfVEFHID0gTW9ub21vcnBoaWNUYWdJbXBsLnVwZGF0ZVRhZztcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGFnKCk6IERpcnR5YWJsZVRhZyB7XG4gIHJldHVybiBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVwZGF0YWJsZVRhZygpOiBVcGRhdGFibGVUYWcge1xuICByZXR1cm4gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZSk7XG59XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNvbnN0IENPTlNUQU5UX1RBRzogQ29uc3RhbnRUYWcgPSBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuQ29uc3RhbnQpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdFRhZyh0YWc6IFRhZyk6IHRhZyBpcyBDb25zdGFudFRhZyB7XG4gIHJldHVybiB0YWcgPT09IENPTlNUQU5UX1RBRztcbn1cblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY2xhc3MgVm9sYXRpbGVUYWcgaW1wbGVtZW50cyBUYWcge1xuICBbQ09NUFVURV0oKTogUmV2aXNpb24ge1xuICAgIHJldHVybiBWT0xBVElMRTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVk9MQVRJTEVfVEFHID0gbmV3IFZvbGF0aWxlVGFnKCk7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNsYXNzIEN1cnJlbnRUYWcgaW1wbGVtZW50cyBDdXJyZW50VGFnIHtcbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICByZXR1cm4gJFJFVklTSU9OO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDVVJSRU5UX1RBRyA9IG5ldyBDdXJyZW50VGFnKCk7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNvbnN0IGNvbWJpbmUgPSBNb25vbW9ycGhpY1RhZ0ltcGwuY29tYmluZTtcblxuLy8gV2FybVxuXG5sZXQgdGFnMSA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xubGV0IHRhZzIgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbmxldCB0YWczID0gY3JlYXRlVXBkYXRhYmxlVGFnKCk7XG5cbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzEpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5VUERBVEVfVEFHKHRhZzEsIGNvbWJpbmUoW3RhZzIsIHRhZzNdKSk7XG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWcyKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzMpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5VUERBVEVfVEFHKHRhZzEsIHRhZzMpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5ESVJUWV9UQUcodGFnMyk7XG52YWx1ZUZvclRhZyh0YWcxKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=