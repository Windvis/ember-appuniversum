"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bump = bump;
exports.valueForTag = valueForTag;
exports.validateTag = validateTag;
exports.createTag = createTag;
exports.createUpdatableTag = createUpdatableTag;
exports.isConstTag = isConstTag;
exports.combine = exports.CURRENT_TAG = exports.CurrentTag = exports.VOLATILE_TAG = exports.VolatileTag = exports.CONSTANT_TAG = exports.UPDATE_TAG = exports.DIRTY_TAG = exports.ALLOW_CYCLES = exports.COMPUTE = exports.VOLATILE = exports.INITIAL = exports.CONSTANT = void 0;

var _env = require("@glimmer/env");

var _globalContext = require("@glimmer/global-context");

var _utils = require("./utils");

var _debug = require("./debug");

const CONSTANT = 0;
exports.CONSTANT = CONSTANT;
const INITIAL = 1;
exports.INITIAL = INITIAL;
const VOLATILE = NaN;
exports.VOLATILE = VOLATILE;
let $REVISION = INITIAL;

function bump() {
  $REVISION++;
} //////////


const COMPUTE = (0, _utils.symbol)('TAG_COMPUTE'); //////////

/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */

exports.COMPUTE = COMPUTE;

function valueForTag(tag) {
  return tag[COMPUTE]();
}
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */


function validateTag(tag, snapshot) {
  return snapshot >= tag[COMPUTE]();
}

const TYPE = (0, _utils.symbol)('TAG_TYPE'); // this is basically a const
// eslint-disable-next-line @typescript-eslint/naming-convention

let ALLOW_CYCLES;
exports.ALLOW_CYCLES = ALLOW_CYCLES;

if (_env.DEBUG) {
  exports.ALLOW_CYCLES = ALLOW_CYCLES = new WeakMap();
}

function allowsCycles(tag) {
  if (ALLOW_CYCLES === undefined) {
    return true;
  } else {
    return ALLOW_CYCLES.has(tag);
  }
}

class MonomorphicTagImpl {
  constructor(type) {
    this.revision = INITIAL;
    this.lastChecked = INITIAL;
    this.lastValue = INITIAL;
    this.isUpdating = false;
    this.subtag = null;
    this.subtagBufferCache = null;
    this[TYPE] = type;
  }

  static combine(tags) {
    switch (tags.length) {
      case 0:
        return CONSTANT_TAG;

      case 1:
        return tags[0];

      default:
        let tag = new MonomorphicTagImpl(2
        /* Combinator */
        );
        tag.subtag = tags;
        return tag;
    }
  }

  [COMPUTE]() {
    let {
      lastChecked
    } = this;

    if (this.isUpdating === true) {
      if (_env.DEBUG && !allowsCycles(this)) {
        throw new Error('Cycles in tags are not allowed');
      }

      this.lastChecked = ++$REVISION;
    } else if (lastChecked !== $REVISION) {
      this.isUpdating = true;
      this.lastChecked = $REVISION;

      try {
        let {
          subtag,
          revision
        } = this;

        if (subtag !== null) {
          if (Array.isArray(subtag)) {
            for (let i = 0; i < subtag.length; i++) {
              let value = subtag[i][COMPUTE]();
              revision = Math.max(value, revision);
            }
          } else {
            let subtagValue = subtag[COMPUTE]();

            if (subtagValue === this.subtagBufferCache) {
              revision = Math.max(revision, this.lastValue);
            } else {
              // Clear the temporary buffer cache
              this.subtagBufferCache = null;
              revision = Math.max(revision, subtagValue);
            }
          }
        }

        this.lastValue = revision;
      } finally {
        this.isUpdating = false;
      }
    }

    return this.lastValue;
  }

  static updateTag(_tag, _subtag) {
    if (_env.DEBUG && _tag[TYPE] !== 1
    /* Updatable */
    ) {
        throw new Error('Attempted to update a tag that was not updatable');
      } // TODO: TS 3.7 should allow us to do this via assertion


    let tag = _tag;
    let subtag = _subtag;

    if (subtag === CONSTANT_TAG) {
      tag.subtag = null;
    } else {
      // There are two different possibilities when updating a subtag:
      //
      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();
      // 2. subtag[COMPUTE]() > tag[COMPUTE]();
      //
      // The first possibility is completely fine within our caching model, but
      // the second possibility presents a problem. If the parent tag has
      // already been read, then it's value is cached and will not update to
      // reflect the subtag's greater value. Next time the cache is busted, the
      // subtag's value _will_ be read, and it's value will be _greater_ than
      // the saved snapshot of the parent, causing the resulting calculation to
      // be rerun erroneously.
      //
      // In order to prevent this, when we first update to a new subtag we store
      // its computed value, and then check against that computed value on
      // subsequent updates. If its value hasn't changed, then we return the
      // parent's previous value. Once the subtag changes for the first time,
      // we clear the cache and everything is finally in sync with the parent.
      tag.subtagBufferCache = subtag[COMPUTE]();
      tag.subtag = subtag;
    }
  }

  static dirtyTag(tag) {
    if (_env.DEBUG && !(tag[TYPE] === 1
    /* Updatable */
    || tag[TYPE] === 0
    /* Dirtyable */
    )) {
      throw new Error('Attempted to dirty a tag that was not dirtyable');
    }

    if (_env.DEBUG) {
      // Usually by this point, we've already asserted with better error information,
      // but this is our last line of defense.
      (0, _utils.unwrap)(_debug.assertTagNotConsumed)(tag);
    }

    tag.revision = ++$REVISION;
    (0, _globalContext.scheduleRevalidate)();
  }

}

const DIRTY_TAG = MonomorphicTagImpl.dirtyTag;
exports.DIRTY_TAG = DIRTY_TAG;
const UPDATE_TAG = MonomorphicTagImpl.updateTag; //////////

exports.UPDATE_TAG = UPDATE_TAG;

function createTag() {
  return new MonomorphicTagImpl(0
  /* Dirtyable */
  );
}

function createUpdatableTag() {
  return new MonomorphicTagImpl(1
  /* Updatable */
  );
} //////////


const CONSTANT_TAG = new MonomorphicTagImpl(3
/* Constant */
);
exports.CONSTANT_TAG = CONSTANT_TAG;

function isConstTag(tag) {
  return tag === CONSTANT_TAG;
} //////////


class VolatileTag {
  [COMPUTE]() {
    return VOLATILE;
  }

}

exports.VolatileTag = VolatileTag;
const VOLATILE_TAG = new VolatileTag(); //////////

exports.VOLATILE_TAG = VOLATILE_TAG;

class CurrentTag {
  [COMPUTE]() {
    return $REVISION;
  }

}

exports.CurrentTag = CurrentTag;
const CURRENT_TAG = new CurrentTag(); //////////

exports.CURRENT_TAG = CURRENT_TAG;
const combine = MonomorphicTagImpl.combine; // Warm

exports.combine = combine;
let tag1 = createUpdatableTag();
let tag2 = createUpdatableTag();
let tag3 = createUpdatableTag();
valueForTag(tag1);
DIRTY_TAG(tag1);
valueForTag(tag1);
UPDATE_TAG(tag1, combine([tag2, tag3]));
valueForTag(tag1);
DIRTY_TAG(tag2);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
UPDATE_TAG(tag1, tag3);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBTU8sTUFBTSxRQUFRLEdBQWQsQ0FBQTs7QUFDQSxNQUFNLE9BQU8sR0FBYixDQUFBOztBQUNBLE1BQU0sUUFBUSxHQUFkLEdBQUE7O0FBRVAsSUFBSSxTQUFTLEdBQWIsT0FBQTs7QUFFTSxTQUFBLElBQUEsR0FBYztBQUNsQixFQUFBLFNBQVM7RUFHWDs7O0FBRU8sTUFBTSxPQUFPLEdBQWtCLG1CQUEvQixhQUErQixDQUEvQixDLENBUVA7O0FBRUE7Ozs7Ozs7Ozs7O0FBUU0sU0FBQSxXQUFBLENBQUEsR0FBQSxFQUE4QjtBQUNsQyxTQUFPLEdBQUcsQ0FBVixPQUFVLENBQUgsRUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7OztBQVVNLFNBQUEsV0FBQSxDQUFBLEdBQUEsRUFBQSxRQUFBLEVBQWtEO0FBQ3RELFNBQU8sUUFBUSxJQUFJLEdBQUcsQ0FBdEIsT0FBc0IsQ0FBSCxFQUFuQjtBQUNEOztBQWlCRCxNQUFNLElBQUksR0FBa0IsbUJBQTVCLFVBQTRCLENBQTVCLEMsQ0FFQTtBQUNBOztBQUNPLElBQUEsWUFBQTs7O0FBRVAsSUFBQSxVQUFBLEVBQVc7QUFDVCx5QkFBQSxZQUFZLEdBQUcsSUFBZixPQUFlLEVBQWY7QUFDRDs7QUFFRCxTQUFBLFlBQUEsQ0FBQSxHQUFBLEVBQThCO0FBQzVCLE1BQUksWUFBWSxLQUFoQixTQUFBLEVBQWdDO0FBQzlCLFdBQUEsSUFBQTtBQURGLEdBQUEsTUFFTztBQUNMLFdBQU8sWUFBWSxDQUFaLEdBQUEsQ0FBUCxHQUFPLENBQVA7QUFDRDtBQUNGOztBQVdELE1BQUEsa0JBQUEsQ0FBd0I7QUF1QnRCLEVBQUEsV0FBQSxDQUFBLElBQUEsRUFBbUI7QUFWWCxTQUFBLFFBQUEsR0FBQSxPQUFBO0FB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R0FBRyxJQUFyQixXQUFxQixFQUFyQixDLENBRVA7Ozs7QUFFTSxNQUFBLFVBQUEsQ0FBaUI7QUFDckIsR0FBQSxPQUFBLElBQVM7QUFDUCxXQUFBLFNBQUE7QUFDRDs7QUFIb0I7OztBQU1oQixNQUFNLFdBQVcsR0FBRyxJQUFwQixVQUFvQixFQUFwQixDLENBRVA7OztBQUVPLE1BQU0sT0FBTyxHQUFHLGtCQUFrQixDQUFsQyxPQUFBLEMsQ0FFUDs7O0FBRUEsSUFBSSxJQUFJLEdBQUcsa0JBQVgsRUFBQTtBQUNBLElBQUksSUFBSSxHQUFHLGtCQUFYLEVBQUE7QUFDQSxJQUFJLElBQUksR0FBRyxrQkFBWCxFQUFBO0FBRUEsV0FBVyxDQUFYLElBQVcsQ0FBWDtBQUNBLFNBQVMsQ0FBVCxJQUFTLENBQVQ7QUFDQSxXQUFXLENBQVgsSUFBVyxDQUFYO0FBQ0EsVUFBVSxDQUFBLElBQUEsRUFBTyxPQUFPLENBQUMsQ0FBQSxJQUFBLEVBQXpCLElBQXlCLENBQUQsQ0FBZCxDQUFWO0FBQ0EsV0FBVyxDQUFYLElBQVcsQ0FBWDtBQUNBLFNBQVMsQ0FBVCxJQUFTLENBQVQ7QUFDQSxXQUFXLENBQVgsSUFBVyxDQUFYO0FBQ0EsU0FBUyxDQUFULElBQVMsQ0FBVDtBQUNBLFdBQVcsQ0FBWCxJQUFXLENBQVg7QUFDQSxVQUFVLENBQUEsSUFBQSxFQUFWLElBQVUsQ0FBVjtBQUNBLFdBQVcsQ0FBWCxJQUFXLENBQVg7QUFDQSxTQUFTLENBQVQsSUFBUyxDQUFUO0FBQ0EsV0FBVyxDQUFYLElBQVcsQ0FBWCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHNjaGVkdWxlUmV2YWxpZGF0ZSB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcbmltcG9ydCB7IHN5bWJvbCwgdW53cmFwIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBhc3NlcnRUYWdOb3RDb25zdW1lZCB9IGZyb20gJy4vZGVidWcnO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIFJldmlzaW9uID0gbnVtYmVyO1xuXG5leHBvcnQgY29uc3QgQ09OU1RBTlQ6IFJldmlzaW9uID0gMDtcbmV4cG9ydCBjb25zdCBJTklUSUFMOiBSZXZpc2lvbiA9IDE7XG5leHBvcnQgY29uc3QgVk9MQVRJTEU6IFJldmlzaW9uID0gTmFOO1xuXG5sZXQgJFJFVklTSU9OID0gSU5JVElBTDtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXAoKTogdm9pZCB7XG4gICRSRVZJU0lPTisrO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT01QVVRFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUQUdfQ09NUFVURScpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eVRhZzxUPiB7XG4gIFtDT01QVVRFXSgpOiBUO1xufVxuXG5leHBvcnQgdHlwZSBUYWcgPSBFbnRpdHlUYWc8UmV2aXNpb24+O1xuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogYHZhbHVlYCByZWNlaXZlcyBhIHRhZyBhbmQgcmV0dXJucyBhbiBvcGFxdWUgUmV2aXNpb24gYmFzZWQgb24gdGhhdCB0YWcuIFRoaXNcbiAqIHNuYXBzaG90IGNhbiB0aGVuIGxhdGVyIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIHdpdGggdGhlIHNhbWUgdGFnIHRvXG4gKiBkZXRlcm1pbmUgaWYgdGhlIHRhZyBoYXMgY2hhbmdlZCBhdCBhbGwgc2luY2UgdGhlIHRpbWUgdGhhdCBgdmFsdWVgIHdhc1xuICogY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlRm9yVGFnKHRhZzogVGFnKTogUmV2aXNpb24ge1xuICByZXR1cm4gdGFnW0NPTVBVVEVdKCk7XG59XG5cbi8qKlxuICogYHZhbGlkYXRlYCByZWNlaXZlcyBhIHRhZyBhbmQgYSBzbmFwc2hvdCBmcm9tIGEgcHJldmlvdXMgY2FsbCB0byBgdmFsdWVgIHdpdGhcbiAqIHRoZSBzYW1lIHRhZywgYW5kIGRldGVybWluZXMgaWYgdGhlIHRhZyBpcyBzdGlsbCB2YWxpZCBjb21wYXJlZCB0byB0aGVcbiAqIHNuYXBzaG90LiBJZiB0aGUgdGFnJ3Mgc3RhdGUgaGFzIGNoYW5nZWQgYXQgYWxsIHNpbmNlIHRoZW4sIGB2YWxpZGF0ZWAgd2lsbFxuICogcmV0dXJuIGZhbHNlLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gdHJ1ZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhXG4gKiBjYWxjdWxhdGlvbiByZWxhdGVkIHRvIHRoZSB0YWdzIHNob3VsZCBiZSByZXJ1bi5cbiAqXG4gKiBAcGFyYW0gdGFnXG4gKiBAcGFyYW0gc25hcHNob3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVGFnKHRhZzogVGFnLCBzbmFwc2hvdDogUmV2aXNpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHNuYXBzaG90ID49IHRhZ1tDT01QVVRFXSgpO1xufVxuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogVGhpcyBlbnVtIHJlcHJlc2VudHMgYWxsIG9mIHRoZSBwb3NzaWJsZSB0YWcgdHlwZXMgZm9yIHRoZSBtb25vbW9ycGhpYyB0YWcgY2xhc3MuXG4gKiBPdGhlciBjdXN0b20gdGFnIGNsYXNzZXMgY2FuIGV4aXN0LCBzdWNoIGFzIEN1cnJlbnRUYWcgYW5kIFZvbGF0aWxlVGFnLCBidXQgZm9yXG4gKiBwZXJmb3JtYW5jZSByZWFzb25zLCBhbnkgdHlwZSBvZiB0YWcgdGhhdCBpcyBtZWFudCB0byBiZSB1c2VkIGZyZXF1ZW50bHkgc2hvdWxkXG4gKiBiZSBhZGRlZCB0byB0aGUgbW9ub21vcnBoaWMgdGFnLlxuICovXG5jb25zdCBlbnVtIE1vbm9tb3JwaGljVGFnVHlwZXMge1xuICBEaXJ0eWFibGUsXG4gIFVwZGF0YWJsZSxcbiAgQ29tYmluYXRvcixcbiAgQ29uc3RhbnQsXG59XG5cbmNvbnN0IFRZUEU6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1RBR19UWVBFJyk7XG5cbi8vIHRoaXMgaXMgYmFzaWNhbGx5IGEgY29uc3Rcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBsZXQgQUxMT1dfQ1lDTEVTOiBXZWFrTWFwPFRhZywgYm9vbGVhbj4gfCB1bmRlZmluZWQ7XG5cbmlmIChERUJVRykge1xuICBBTExPV19DWUNMRVMgPSBuZXcgV2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBhbGxvd3NDeWNsZXModGFnOiBUYWcpOiBib29sZWFuIHtcbiAgaWYgKEFMTE9XX0NZQ0xFUyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFMTE9XX0NZQ0xFUy5oYXModGFnKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgTW9ub21vcnBoaWNUYWdCYXNlPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzPiBleHRlbmRzIFRhZyB7XG4gIFtUWVBFXTogVDtcbn1cblxuZXhwb3J0IHR5cGUgRGlydHlhYmxlVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlPjtcbmV4cG9ydCB0eXBlIFVwZGF0YWJsZVRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZT47XG5leHBvcnQgdHlwZSBDb21iaW5hdG9yVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuQ29tYmluYXRvcj47XG5leHBvcnQgdHlwZSBDb25zdGFudFRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbnN0YW50PjtcblxuY2xhc3MgTW9ub21vcnBoaWNUYWdJbXBsPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzID0gTW9ub21vcnBoaWNUYWdUeXBlcz4ge1xuICBzdGF0aWMgY29tYmluZSh0YWdzOiBUYWdbXSk6IFRhZyB7XG4gICAgc3dpdGNoICh0YWdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gQ09OU1RBTlRfVEFHO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGFnc1swXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0YWc6IE1vbm9tb3JwaGljVGFnSW1wbCA9IG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5Db21iaW5hdG9yKTtcbiAgICAgICAgdGFnLnN1YnRhZyA9IHRhZ3M7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgcmV2aXNpb24gPSBJTklUSUFMO1xuICBwcml2YXRlIGxhc3RDaGVja2VkID0gSU5JVElBTDtcbiAgcHJpdmF0ZSBsYXN0VmFsdWUgPSBJTklUSUFMO1xuXG4gIHByaXZhdGUgaXNVcGRhdGluZyA9IGZhbHNlO1xuICBwcml2YXRlIHN1YnRhZzogVGFnIHwgVGFnW10gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdWJ0YWdCdWZmZXJDYWNoZTogUmV2aXNpb24gfCBudWxsID0gbnVsbDtcblxuICBbVFlQRV06IFQ7XG5cbiAgY29uc3RydWN0b3IodHlwZTogVCkge1xuICAgIHRoaXNbVFlQRV0gPSB0eXBlO1xuICB9XG5cbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICBsZXQgeyBsYXN0Q2hlY2tlZCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzVXBkYXRpbmcgPT09IHRydWUpIHtcbiAgICAgIGlmIChERUJVRyAmJiAhYWxsb3dzQ3ljbGVzKHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGVzIGluIHRhZ3MgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdENoZWNrZWQgPSArKyRSRVZJU0lPTjtcbiAgICB9IGVsc2UgaWYgKGxhc3RDaGVja2VkICE9PSAkUkVWSVNJT04pIHtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RDaGVja2VkID0gJFJFVklTSU9OO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyBzdWJ0YWcsIHJldmlzaW9uIH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdWJ0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJ0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBzdWJ0YWdbaV1bQ09NUFVURV0oKTtcbiAgICAgICAgICAgICAgcmV2aXNpb24gPSBNYXRoLm1heCh2YWx1ZSwgcmV2aXNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3VidGFnVmFsdWUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcblxuICAgICAgICAgICAgaWYgKHN1YnRhZ1ZhbHVlID09PSB0aGlzLnN1YnRhZ0J1ZmZlckNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldmlzaW9uID0gTWF0aC5tYXgocmV2aXNpb24sIHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0ZW1wb3JhcnkgYnVmZmVyIGNhY2hlXG4gICAgICAgICAgICAgIHRoaXMuc3VidGFnQnVmZmVyQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICByZXZpc2lvbiA9IE1hdGgubWF4KHJldmlzaW9uLCBzdWJ0YWdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSByZXZpc2lvbjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhc3RWYWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVUYWcoX3RhZzogVXBkYXRhYmxlVGFnLCBfc3VidGFnOiBUYWcpIHtcbiAgICBpZiAoREVCVUcgJiYgX3RhZ1tUWVBFXSAhPT0gTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVwZGF0ZSBhIHRhZyB0aGF0IHdhcyBub3QgdXBkYXRhYmxlJyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVFMgMy43IHNob3VsZCBhbGxvdyB1cyB0byBkbyB0aGlzIHZpYSBhc3NlcnRpb25cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBNb25vbW9ycGhpY1RhZ0ltcGw7XG4gICAgbGV0IHN1YnRhZyA9IF9zdWJ0YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsO1xuXG4gICAgaWYgKHN1YnRhZyA9PT0gQ09OU1RBTlRfVEFHKSB7XG4gICAgICB0YWcuc3VidGFnID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgcG9zc2liaWxpdGllcyB3aGVuIHVwZGF0aW5nIGEgc3VidGFnOlxuICAgICAgLy9cbiAgICAgIC8vIDEuIHN1YnRhZ1tDT01QVVRFXSgpIDw9IHRhZ1tDT01QVVRFXSgpO1xuICAgICAgLy8gMi4gc3VidGFnW0NPTVBVVEVdKCkgPiB0YWdbQ09NUFVURV0oKTtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgZmlyc3QgcG9zc2liaWxpdHkgaXMgY29tcGxldGVseSBmaW5lIHdpdGhpbiBvdXIgY2FjaGluZyBtb2RlbCwgYnV0XG4gICAgICAvLyB0aGUgc2Vjb25kIHBvc3NpYmlsaXR5IHByZXNlbnRzIGEgcHJvYmxlbS4gSWYgdGhlIHBhcmVudCB0YWcgaGFzXG4gICAgICAvLyBhbHJlYWR5IGJlZW4gcmVhZCwgdGhlbiBpdCdzIHZhbHVlIGlzIGNhY2hlZCBhbmQgd2lsbCBub3QgdXBkYXRlIHRvXG4gICAgICAvLyByZWZsZWN0IHRoZSBzdWJ0YWcncyBncmVhdGVyIHZhbHVlLiBOZXh0IHRpbWUgdGhlIGNhY2hlIGlzIGJ1c3RlZCwgdGhlXG4gICAgICAvLyBzdWJ0YWcncyB2YWx1ZSBfd2lsbF8gYmUgcmVhZCwgYW5kIGl0J3MgdmFsdWUgd2lsbCBiZSBfZ3JlYXRlcl8gdGhhblxuICAgICAgLy8gdGhlIHNhdmVkIHNuYXBzaG90IG9mIHRoZSBwYXJlbnQsIGNhdXNpbmcgdGhlIHJlc3VsdGluZyBjYWxjdWxhdGlvbiB0b1xuICAgICAgLy8gYmUgcmVydW4gZXJyb25lb3VzbHkuXG4gICAgICAvL1xuICAgICAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCB0aGlzLCB3aGVuIHdlIGZpcnN0IHVwZGF0ZSB0byBhIG5ldyBzdWJ0YWcgd2Ugc3RvcmVcbiAgICAgIC8vIGl0cyBjb21wdXRlZCB2YWx1ZSwgYW5kIHRoZW4gY2hlY2sgYWdhaW5zdCB0aGF0IGNvbXB1dGVkIHZhbHVlIG9uXG4gICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuIElmIGl0cyB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgdGhlbiB3ZSByZXR1cm4gdGhlXG4gICAgICAvLyBwYXJlbnQncyBwcmV2aW91cyB2YWx1ZS4gT25jZSB0aGUgc3VidGFnIGNoYW5nZXMgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIGFuZCBldmVyeXRoaW5nIGlzIGZpbmFsbHkgaW4gc3luYyB3aXRoIHRoZSBwYXJlbnQuXG4gICAgICB0YWcuc3VidGFnQnVmZmVyQ2FjaGUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcbiAgICAgIHRhZy5zdWJ0YWcgPSBzdWJ0YWc7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRpcnR5VGFnKHRhZzogRGlydHlhYmxlVGFnIHwgVXBkYXRhYmxlVGFnKSB7XG4gICAgaWYgKFxuICAgICAgREVCVUcgJiZcbiAgICAgICEodGFnW1RZUEVdID09PSBNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZSB8fCB0YWdbVFlQRV0gPT09IE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gZGlydHkgYSB0YWcgdGhhdCB3YXMgbm90IGRpcnR5YWJsZScpO1xuICAgIH1cblxuICAgIGlmIChERUJVRykge1xuICAgICAgLy8gVXN1YWxseSBieSB0aGlzIHBvaW50LCB3ZSd2ZSBhbHJlYWR5IGFzc2VydGVkIHdpdGggYmV0dGVyIGVycm9yIGluZm9ybWF0aW9uLFxuICAgICAgLy8gYnV0IHRoaXMgaXMgb3VyIGxhc3QgbGluZSBvZiBkZWZlbnNlLlxuICAgICAgdW53cmFwKGFzc2VydFRhZ05vdENvbnN1bWVkKSh0YWcpO1xuICAgIH1cblxuICAgICh0YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsKS5yZXZpc2lvbiA9ICsrJFJFVklTSU9OO1xuXG4gICAgc2NoZWR1bGVSZXZhbGlkYXRlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERJUlRZX1RBRyA9IE1vbm9tb3JwaGljVGFnSW1wbC5kaXJ0eVRhZztcbmV4cG9ydCBjb25zdCBVUERBVEVfVEFHID0gTW9ub21vcnBoaWNUYWdJbXBsLnVwZGF0ZVRhZztcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGFnKCk6IERpcnR5YWJsZVRhZyB7XG4gIHJldHVybiBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVwZGF0YWJsZVRhZygpOiBVcGRhdGFibGVUYWcge1xuICByZXR1cm4gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZSk7XG59XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNvbnN0IENPTlNUQU5UX1RBRzogQ29uc3RhbnRUYWcgPSBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuQ29uc3RhbnQpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdFRhZyh0YWc6IFRhZyk6IHRhZyBpcyBDb25zdGFudFRhZyB7XG4gIHJldHVybiB0YWcgPT09IENPTlNUQU5UX1RBRztcbn1cblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY2xhc3MgVm9sYXRpbGVUYWcgaW1wbGVtZW50cyBUYWcge1xuICBbQ09NUFVURV0oKTogUmV2aXNpb24ge1xuICAgIHJldHVybiBWT0xBVElMRTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVk9MQVRJTEVfVEFHID0gbmV3IFZvbGF0aWxlVGFnKCk7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNsYXNzIEN1cnJlbnRUYWcgaW1wbGVtZW50cyBDdXJyZW50VGFnIHtcbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICByZXR1cm4gJFJFVklTSU9OO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDVVJSRU5UX1RBRyA9IG5ldyBDdXJyZW50VGFnKCk7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNvbnN0IGNvbWJpbmUgPSBNb25vbW9ycGhpY1RhZ0ltcGwuY29tYmluZTtcblxuLy8gV2FybVxuXG5sZXQgdGFnMSA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xubGV0IHRhZzIgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbmxldCB0YWczID0gY3JlYXRlVXBkYXRhYmxlVGFnKCk7XG5cbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzEpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5VUERBVEVfVEFHKHRhZzEsIGNvbWJpbmUoW3RhZzIsIHRhZzNdKSk7XG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWcyKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzMpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5VUERBVEVfVEFHKHRhZzEsIHRhZzMpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5ESVJUWV9UQUcodGFnMyk7XG52YWx1ZUZvclRhZyh0YWcxKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=